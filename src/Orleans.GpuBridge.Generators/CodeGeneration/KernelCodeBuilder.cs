// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans
// Copyright (c) 2025 Michael Ivertowski

using System;
using System.Linq;
using System.Text;
using Orleans.GpuBridge.Generators.Models;

#pragma warning disable IDE0130 // Namespace does not match folder structure

namespace Orleans.GpuBridge.Generators.CodeGeneration;

/// <summary>
/// Generates DotCompute [RingKernel] handler code for GPU-native message processing.
/// </summary>
/// <remarks>
/// <para>
/// The generated kernel code follows the ring kernel pattern:
/// <list type="bullet">
/// <item><description>Persistent kernel running infinite dispatch loops</description></item>
/// <item><description>Message type-based dispatch switch</description></item>
/// <item><description>Blittable struct request/response handling</description></item>
/// <item><description>GPU-side temporal clock updates</description></item>
/// </list>
/// </para>
/// </remarks>
public static class KernelCodeBuilder
{
    /// <summary>
    /// Generates the complete kernel code for a GPU actor.
    /// </summary>
    /// <param name="actor">The actor information.</param>
    /// <returns>Generated C# source code with [RingKernel] attribute.</returns>
    public static string GenerateKernelCode(GpuActorInfo actor)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// This file was generated by Orleans.GpuBridge.Generators.");
        sb.AppendLine("// Do not edit this file directly.");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using DotCompute.Abstractions.Attributes;");
        sb.AppendLine("using DotCompute.Abstractions.RingKernels;");
        sb.AppendLine("using Orleans.GpuBridge.Runtime.K2K;");

        if (actor.HasTemporalOrdering)
        {
            sb.AppendLine("using Orleans.GpuBridge.Abstractions.Temporal;");
        }

        if (actor.HasK2KTargets)
        {
            sb.AppendLine("using Orleans.GpuBridge.Runtime.Routing;");
        }

        sb.AppendLine($"using {actor.Namespace}.Generated;");
        sb.AppendLine();
        sb.AppendLine($"namespace {actor.Namespace}.Generated.Kernels;");
        sb.AppendLine();

        // Kernel class
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// GPU kernel handlers for {actor.InterfaceName}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static partial class {actor.KernelClassName}");
        sb.AppendLine("{");

        // Generate kernel constants
        GenerateKernelConstants(sb, actor);
        sb.AppendLine();

        // Generate the main dispatch kernel
        GenerateDispatchKernel(sb, actor);
        sb.AppendLine();

        // Generate individual handler kernels
        foreach (var handler in actor.Handlers)
        {
            GenerateHandlerKernel(sb, actor, handler);
            sb.AppendLine();
        }

        // Generate temporal helper if needed
        if (actor.HasTemporalOrdering)
        {
            GenerateTemporalHelpers(sb, actor);
            sb.AppendLine();
        }

        // Generate K2K dispatch helpers if needed
        if (actor.HasK2KTargets)
        {
            GenerateK2KDispatchHelpers(sb, actor);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates kernel constants for dispatch.
    /// </summary>
    private static void GenerateKernelConstants(StringBuilder sb, GpuActorInfo actor)
    {
        sb.AppendLine("    #region Kernel Constants");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Maximum message payload size in bytes.");
        sb.AppendLine("    /// </summary>");

        var maxPayload = actor.Handlers.Any()
            ? actor.Handlers.Max(h => h.MaxPayloadSize)
            : 228;

        sb.AppendLine($"    public const int MaxPayloadSize = {maxPayload};");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Default queue depth for message processing.");
        sb.AppendLine("    /// </summary>");

        var maxQueue = actor.Handlers.Any()
            ? actor.Handlers.Max(h => h.QueueDepth)
            : 1024;

        sb.AppendLine($"    public const int DefaultQueueDepth = {maxQueue};");
        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    /// <summary>
    /// Generates the main dispatch kernel that routes messages to handlers.
    /// </summary>
    private static void GenerateDispatchKernel(StringBuilder sb, GpuActorInfo actor)
    {
        sb.AppendLine("    #region Dispatch Kernel");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Main dispatch kernel for {actor.InterfaceName} messages.");
        sb.AppendLine("    /// Routes incoming messages to appropriate handlers based on message type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [RingKernel(");
        sb.AppendLine($"        KernelId = \"{actor.KernelClassName}Dispatch\",");
        sb.AppendLine($"        InputQueueSize = DefaultQueueDepth,");
        sb.AppendLine($"        OutputQueueSize = DefaultQueueDepth,");
        sb.AppendLine($"        Domain = RingKernelDomain.ActorModel)]");

        if (actor.HasState)
        {
            sb.AppendLine($"    public static void Dispatch(");
            sb.AppendLine($"        ReadOnlySpan<byte> requestBuffer,");
            sb.AppendLine($"        Span<byte> responseBuffer,");
            sb.AppendLine($"        ref {actor.StateStructName} state)");
        }
        else
        {
            sb.AppendLine($"    public static void Dispatch(");
            sb.AppendLine($"        ReadOnlySpan<byte> requestBuffer,");
            sb.AppendLine($"        Span<byte> responseBuffer)");
        }

        sb.AppendLine("    {");
        sb.AppendLine("        // Read message type from first 4 bytes");
        sb.AppendLine("        var messageType = MemoryMarshal.Read<int>(requestBuffer);");
        sb.AppendLine();
        sb.AppendLine("        // Dispatch to appropriate handler");
        sb.AppendLine("        switch (messageType)");
        sb.AppendLine("        {");

        foreach (var handler in actor.Handlers)
        {
            var handlerMethodName = GetHandlerMethodName(handler);
            sb.AppendLine($"            case {handler.MessageTypeId}:");
            sb.AppendLine($"                {handlerMethodName}(requestBuffer, responseBuffer{(actor.HasState ? ", ref state" : "")});");
            sb.AppendLine("                break;");
            sb.AppendLine();
        }

        sb.AppendLine("            default:");
        sb.AppendLine("                // Unknown message type - write error status");
        sb.AppendLine("                MemoryMarshal.Write(responseBuffer, -1);");
        sb.AppendLine("                break;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    /// <summary>
    /// Generates an individual handler kernel method.
    /// </summary>
    private static void GenerateHandlerKernel(StringBuilder sb, GpuActorInfo actor, GpuHandlerInfo handler)
    {
        var handlerMethodName = GetHandlerMethodName(handler);

        sb.AppendLine($"    #region {handler.MethodName} Handler");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Handler kernel for {handler.MethodName}.");
        sb.AppendLine("    /// </summary>");

        if (actor.HasState)
        {
            sb.AppendLine($"    private static void {handlerMethodName}(");
            sb.AppendLine($"        ReadOnlySpan<byte> requestBuffer,");
            sb.AppendLine($"        Span<byte> responseBuffer,");
            sb.AppendLine($"        ref {actor.StateStructName} state)");
        }
        else
        {
            sb.AppendLine($"    private static void {handlerMethodName}(");
            sb.AppendLine($"        ReadOnlySpan<byte> requestBuffer,");
            sb.AppendLine($"        Span<byte> responseBuffer)");
        }

        sb.AppendLine("    {");

        // Deserialize request
        sb.AppendLine("        // Deserialize request");
        sb.AppendLine($"        var request = MemoryMarshal.Read<{handler.RequestStructName}>(requestBuffer);");
        sb.AppendLine();

        // Temporal clock handling
        if (actor.HasTemporalOrdering)
        {
            sb.AppendLine("        // Update temporal clock from request");
            sb.AppendLine("        var currentTime = UpdateClock(request.Timestamp, ref state);");
            sb.AppendLine();
        }

        // Generate handler computation
        // Note: Actual computation logic should be provided by the user or
        // extracted from the original handler method via AST analysis.
        // For v0.1.0, we generate a passthrough that copies input to output.
        sb.AppendLine("        // Execute handler logic");
        sb.AppendLine($"        // Handler: {handler.MethodName}");
        sb.AppendLine($"        // This code is auto-generated. Customize the computation below.");

        if (handler.HasReturnValue && handler.ReturnTypeName != "void")
        {
            sb.AppendLine($"        {handler.ReturnTypeName} result = default;");
            sb.AppendLine();

            // Generate computation based on parameters
            if (handler.Parameters.Length >= 2)
            {
                var p1 = handler.Parameters[0];
                var p2 = handler.Parameters[1];
                if (p1.TypeName == handler.ReturnTypeName && p2.TypeName == handler.ReturnTypeName)
                {
                    // Binary operation - generate example computation
                    sb.AppendLine($"        // Binary operation on {p1.TypeName}");
                    sb.AppendLine($"        result = request.{p1.Name} + request.{p2.Name};");
                }
                else if (handler.Parameters.Length == 1 && handler.Parameters[0].TypeName == handler.ReturnTypeName)
                {
                    // Unary passthrough
                    sb.AppendLine($"        // Passthrough");
                    sb.AppendLine($"        result = request.{handler.Parameters[0].Name};");
                }
                else
                {
                    // Generate field copy for first matching parameter
                    sb.AppendLine($"        // Default computation (customize as needed)");
                    foreach (var param in handler.Parameters)
                    {
                        if (param.TypeName == handler.ReturnTypeName)
                        {
                            sb.AppendLine($"        result = request.{param.Name};");
                            break;
                        }
                    }
                }
            }
            else if (handler.Parameters.Length == 1)
            {
                var p = handler.Parameters[0];
                if (p.TypeName == handler.ReturnTypeName)
                {
                    sb.AppendLine($"        // Unary passthrough");
                    sb.AppendLine($"        result = request.{p.Name};");
                }
                else
                {
                    sb.AppendLine($"        // Default value (customize computation as needed)");
                }
            }
        }

        sb.AppendLine();

        // Serialize response
        sb.AppendLine("        // Serialize response");
        sb.AppendLine($"        var response = new {handler.ResponseStructName}");
        sb.AppendLine("        {");
        sb.AppendLine("            Status = 0, // Success");

        if (actor.HasTemporalOrdering)
        {
            sb.AppendLine("            Timestamp = currentTime,");
        }

        if (handler.HasReturnValue && handler.ReturnTypeName != "void")
        {
            sb.AppendLine("            Result = result,");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine($"        MemoryMarshal.Write(responseBuffer, response);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    /// <summary>
    /// Generates temporal helper methods.
    /// </summary>
    private static void GenerateTemporalHelpers(StringBuilder sb, GpuActorInfo actor)
    {
        sb.AppendLine("    #region Temporal Helpers");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Updates the GPU-resident HLC clock.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    private static HybridTimestamp UpdateClock(HybridTimestamp incoming, ref {actor.StateStructName} state)");
        sb.AppendLine("    {");
        sb.AppendLine("        // GPU-side HLC update algorithm");
        sb.AppendLine("        // 1. Get max of (local physical, incoming physical, current wall clock)");
        sb.AppendLine("        // 2. If physical time advanced, reset logical to 0");
        sb.AppendLine("        // 3. Otherwise increment logical counter");
        sb.AppendLine();
        sb.AppendLine("        var local = state.LastModified;");
        sb.AppendLine("        var physicalMax = Math.Max(local.PhysicalTime, incoming.PhysicalTime);");
        sb.AppendLine();
        sb.AppendLine("        HybridTimestamp result;");
        sb.AppendLine("        if (physicalMax > local.PhysicalTime)");
        sb.AppendLine("        {");
        sb.AppendLine("            result = new HybridTimestamp(physicalMax, 0);");
        sb.AppendLine("        }");
        sb.AppendLine("        else if (incoming.PhysicalTime == local.PhysicalTime)");
        sb.AppendLine("        {");
        sb.AppendLine("            result = new HybridTimestamp(physicalMax, (ushort)(Math.Max(local.LogicalTime, incoming.LogicalTime) + 1));");
        sb.AppendLine("        }");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine("            result = new HybridTimestamp(physicalMax, (ushort)(local.LogicalTime + 1));");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        state.LastModified = result;");
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    /// <summary>
    /// Gets the kernel method name for a handler.
    /// </summary>
    private static string GetHandlerMethodName(GpuHandlerInfo handler)
    {
        var name = handler.MethodName;

        // Remove Async suffix for kernel methods
        if (name.EndsWith("Async", StringComparison.Ordinal))
        {
            name = name.Substring(0, name.Length - 5);
        }

        return $"Handle{name}";
    }

    /// <summary>
    /// Generates K2K (Kernel-to-Kernel) dispatch helper methods.
    /// </summary>
    /// <remarks>
    /// K2K messaging enables GPU actors to communicate directly without CPU involvement:
    /// <list type="bullet">
    /// <item><description>Direct: Point-to-point to specific actor by key</description></item>
    /// <item><description>Broadcast: Message to all instances of target actor type</description></item>
    /// <item><description>Ring: Message propagates in ring topology</description></item>
    /// <item><description>HashRouted: Key-based routing for consistent hashing</description></item>
    /// </list>
    /// </remarks>
    private static void GenerateK2KDispatchHelpers(StringBuilder sb, GpuActorInfo actor)
    {
        sb.AppendLine("    #region K2K Dispatch Helpers");
        sb.AppendLine();

        // Collect all unique K2K targets
        var allTargets = actor.Handlers
            .Where(h => !h.K2KTargets.IsDefaultOrEmpty)
            .SelectMany(h => h.K2KTargets)
            .GroupBy(t => t.TargetActorTypeName + "." + t.TargetMethodName)
            .Select(g => g.First())
            .ToList();

        // Generate K2K dispatch table struct
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// K2K dispatch table for routing messages to target actors.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// This table is populated at grain activation with target ring kernel addresses.");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine("    [StructLayout(LayoutKind.Sequential)]");
        sb.AppendLine($"    public struct {actor.KernelClassName}K2KTable");
        sb.AppendLine("    {");

        foreach (var target in allTargets)
        {
            var fieldName = GetK2KTargetFieldName(target);
            sb.AppendLine($"        /// <summary>Ring kernel queue pointer for {target.TargetActorTypeName}.{target.TargetMethodName}.</summary>");
            sb.AppendLine($"        public IntPtr {fieldName}QueuePtr;");
            sb.AppendLine($"        /// <summary>Message type ID for {target.TargetMethodName}.</summary>");
            sb.AppendLine($"        public int {fieldName}MessageTypeId;");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate K2K dispatch methods for each routing strategy
        GenerateK2KDirectDispatch(sb);
        sb.AppendLine();
        GenerateK2KBroadcastDispatch(sb);
        sb.AppendLine();
        GenerateK2KRingDispatch(sb);
        sb.AppendLine();
        GenerateK2KHashRoutedDispatch(sb);

        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    /// <summary>
    /// Generates Direct K2K dispatch method (point-to-point messaging).
    /// </summary>
    private static void GenerateK2KDirectDispatch(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Dispatches a K2K message directly to a specific target actor.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"targetQueuePtr\">Pointer to the target actor's ring kernel queue.</param>");
        sb.AppendLine("    /// <param name=\"messageTypeId\">Message type identifier for the target handler.</param>");
        sb.AppendLine("    /// <param name=\"payload\">The message payload to send.</param>");
        sb.AppendLine("    /// <returns>True if the message was enqueued successfully, false if queue is full.</returns>");
        sb.AppendLine("    private static unsafe bool K2KDispatchDirect(IntPtr targetQueuePtr, int messageTypeId, ReadOnlySpan<byte> payload)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (targetQueuePtr == IntPtr.Zero)");
        sb.AppendLine("            return false;");
        sb.AppendLine();
        sb.AppendLine("        // Cast to ring kernel queue header");
        sb.AppendLine("        var queueHeader = (RingKernelQueueHeader*)targetQueuePtr;");
        sb.AppendLine();
        sb.AppendLine("        // Try to acquire a write slot using atomic operations");
        sb.AppendLine("        var writeIdx = Interlocked.Increment(ref queueHeader->WriteIndex) - 1;");
        sb.AppendLine("        var readIdx = Volatile.Read(ref queueHeader->ReadIndex);");
        sb.AppendLine();
        sb.AppendLine("        // Check if queue is full");
        sb.AppendLine("        if (writeIdx - readIdx >= queueHeader->Capacity)");
        sb.AppendLine("        {");
        sb.AppendLine("            // Rollback write index");
        sb.AppendLine("            Interlocked.Decrement(ref queueHeader->WriteIndex);");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Calculate slot address");
        sb.AppendLine("        var slotIndex = writeIdx % queueHeader->Capacity;");
        sb.AppendLine("        var slotPtr = (byte*)targetQueuePtr + sizeof(RingKernelQueueHeader) + (slotIndex * queueHeader->MessageSize);");
        sb.AppendLine();
        sb.AppendLine("        // Write message type ID");
        sb.AppendLine("        *(int*)slotPtr = messageTypeId;");
        sb.AppendLine();
        sb.AppendLine("        // Copy payload after message type ID");
        sb.AppendLine("        var payloadDest = new Span<byte>(slotPtr + sizeof(int), Math.Min(payload.Length, queueHeader->MessageSize - sizeof(int)));");
        sb.AppendLine("        payload.CopyTo(payloadDest);");
        sb.AppendLine();
        sb.AppendLine("        // Signal message is ready (memory barrier)");
        sb.AppendLine("        Volatile.Write(ref queueHeader->WriteCommitted, writeIdx + 1);");
        sb.AppendLine();
        sb.AppendLine("        return true;");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates Broadcast K2K dispatch method (one-to-many messaging).
    /// </summary>
    private static void GenerateK2KBroadcastDispatch(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Broadcasts a K2K message to all instances of a target actor type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"targetQueuePtrs\">Array of pointers to target actor ring kernel queues.</param>");
        sb.AppendLine("    /// <param name=\"targetCount\">Number of targets in the array.</param>");
        sb.AppendLine("    /// <param name=\"messageTypeId\">Message type identifier for the target handler.</param>");
        sb.AppendLine("    /// <param name=\"payload\">The message payload to broadcast.</param>");
        sb.AppendLine("    /// <returns>Number of targets that successfully received the message.</returns>");
        sb.AppendLine("    private static unsafe int K2KDispatchBroadcast(IntPtr* targetQueuePtrs, int targetCount, int messageTypeId, ReadOnlySpan<byte> payload)");
        sb.AppendLine("    {");
        sb.AppendLine("        var successCount = 0;");
        sb.AppendLine();
        sb.AppendLine("        for (var i = 0; i < targetCount; i++)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (K2KDispatchDirect(targetQueuePtrs[i], messageTypeId, payload))");
        sb.AppendLine("            {");
        sb.AppendLine("                successCount++;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return successCount;");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates Ring K2K dispatch method (ring topology propagation).
    /// </summary>
    private static void GenerateK2KRingDispatch(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Dispatches a K2K message in ring topology (to next neighbor in ring).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"nextNeighborQueuePtr\">Pointer to the next neighbor's ring kernel queue.</param>");
        sb.AppendLine("    /// <param name=\"messageTypeId\">Message type identifier for the target handler.</param>");
        sb.AppendLine("    /// <param name=\"payload\">The message payload to forward.</param>");
        sb.AppendLine("    /// <param name=\"hopCount\">Current hop count (incremented before sending).</param>");
        sb.AppendLine("    /// <param name=\"maxHops\">Maximum hops before message is dropped.</param>");
        sb.AppendLine("    /// <returns>True if message was forwarded, false if dropped or queue full.</returns>");
        sb.AppendLine("    private static unsafe bool K2KDispatchRing(IntPtr nextNeighborQueuePtr, int messageTypeId, ReadOnlySpan<byte> payload, ref int hopCount, int maxHops)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Check hop limit to prevent infinite loops");
        sb.AppendLine("        if (++hopCount > maxHops)");
        sb.AppendLine("            return false;");
        sb.AppendLine();
        sb.AppendLine("        return K2KDispatchDirect(nextNeighborQueuePtr, messageTypeId, payload);");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates HashRouted K2K dispatch method (consistent hashing).
    /// </summary>
    private static void GenerateK2KHashRoutedDispatch(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Dispatches a K2K message using consistent hash routing.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"targetQueuePtrs\">Array of pointers to target actor ring kernel queues.</param>");
        sb.AppendLine("    /// <param name=\"targetCount\">Number of targets in the array.</param>");
        sb.AppendLine("    /// <param name=\"messageTypeId\">Message type identifier for the target handler.</param>");
        sb.AppendLine("    /// <param name=\"routingKey\">Key used to determine target (hashed to select queue).</param>");
        sb.AppendLine("    /// <param name=\"payload\">The message payload to send.</param>");
        sb.AppendLine("    /// <returns>True if the message was enqueued successfully.</returns>");
        sb.AppendLine("    private static unsafe bool K2KDispatchHashRouted(IntPtr* targetQueuePtrs, int targetCount, int messageTypeId, long routingKey, ReadOnlySpan<byte> payload)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (targetCount <= 0)");
        sb.AppendLine("            return false;");
        sb.AppendLine();
        sb.AppendLine("        // Simple hash-based routing using modulo");
        sb.AppendLine("        // For production, consider xxHash or similar fast hash");
        sb.AppendLine("        var hash = routingKey ^ (routingKey >> 32);");
        sb.AppendLine("        var targetIndex = (int)((hash & 0x7FFFFFFF) % targetCount);");
        sb.AppendLine();
        sb.AppendLine("        return K2KDispatchDirect(targetQueuePtrs[targetIndex], messageTypeId, payload);");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Gets a safe field name for a K2K target.
    /// </summary>
    private static string GetK2KTargetFieldName(K2KTargetInfo target)
    {
        // Extract simple type name from fully qualified name
        var typeName = target.TargetActorTypeName;
        var lastDot = typeName.LastIndexOf('.');
        if (lastDot >= 0)
        {
            typeName = typeName.Substring(lastDot + 1);
        }

        // Remove 'I' prefix if present
        if (typeName.StartsWith("I", StringComparison.Ordinal) && typeName.Length > 1 && char.IsUpper(typeName[1]))
        {
            typeName = typeName.Substring(1);
        }

        // Remove 'Async' suffix from method name
        var methodName = target.TargetMethodName;
        if (methodName.EndsWith("Async", StringComparison.Ordinal))
        {
            methodName = methodName.Substring(0, methodName.Length - 5);
        }

        return $"{typeName}_{methodName}";
    }
}
