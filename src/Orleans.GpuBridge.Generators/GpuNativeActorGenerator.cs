// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans
// Copyright (c) 2025 Michael Ivertowski

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Orleans.GpuBridge.Generators.Analysis;
using Orleans.GpuBridge.Generators.CodeGeneration;
using Orleans.GpuBridge.Generators.Diagnostics;
using Orleans.GpuBridge.Generators.Models;

namespace Orleans.GpuBridge.Generators;

/// <summary>
/// Incremental source generator that automatically generates GPU-native actor implementations
/// from interface definitions marked with [GpuNativeActor].
/// </summary>
/// <remarks>
/// <para>
/// This generator transforms a simple interface definition like:
/// <code>
/// [GpuNativeActor]
/// public interface ICalculatorActor : IGrainWithIntegerKey
/// {
///     [GpuHandler]
///     Task&lt;int&gt; AddAsync(int a, int b);
/// }
/// </code>
/// Into a complete GPU-native actor implementation including:
/// <list type="bullet">
/// <item><description>Request/response message structs (blittable for GPU)</description></item>
/// <item><description>Orleans grain implementation with ring kernel integration</description></item>
/// <item><description>DotCompute [RingKernel] handler code</description></item>
/// <item><description>Temporal ordering support (HLC/Vector Clocks)</description></item>
/// <item><description>K2K messaging setup for GPU-to-GPU communication</description></item>
/// </list>
/// </para>
/// <para>
/// The generator provides compile-time validation through diagnostics:
/// <list type="bullet">
/// <item><description>GPUGEN001: Invalid handler return type (must be Task or Task&lt;T&gt;)</description></item>
/// <item><description>GPUGEN002: Non-blittable parameter type</description></item>
/// <item><description>GPUGEN003: Payload exceeds maximum size</description></item>
/// <item><description>GPUGEN007: Missing grain interface inheritance</description></item>
/// </list>
/// </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class GpuNativeActorGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the incremental generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register all attribute sources for compilation
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GpuNativeActorAttribute.g.cs",
                SourceText.From(GenerateGpuNativeActorAttribute(), Encoding.UTF8));
            ctx.AddSource("GpuHandlerAttribute.g.cs",
                SourceText.From(GenerateGpuHandlerAttribute(), Encoding.UTF8));
            ctx.AddSource("GpuStateAttribute.g.cs",
                SourceText.From(GenerateGpuStateAttribute(), Encoding.UTF8));
            ctx.AddSource("K2KTargetAttribute.g.cs",
                SourceText.From(GenerateK2KTargetAttribute(), Encoding.UTF8));
            ctx.AddSource("TemporalOrderedAttribute.g.cs",
                SourceText.From(GenerateTemporalOrderedAttribute(), Encoding.UTF8));
            ctx.AddSource("GpuHandlerMode.g.cs",
                SourceText.From(GenerateGpuHandlerModeEnum(), Encoding.UTF8));
            ctx.AddSource("K2KRoutingStrategy.g.cs",
                SourceText.From(GenerateK2KRoutingStrategyEnum(), Encoding.UTF8));
            ctx.AddSource("TemporalClockType.g.cs",
                SourceText.From(GenerateTemporalClockTypeEnum(), Encoding.UTF8));
        });

        // Create a pipeline that finds all interface declarations with [GpuNativeActor]
        var actorDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateInterface(node),
                transform: static (ctx, ct) => GetActorInfo(ctx, ct))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        // Combine with compilation for additional validation
        var compilationAndActors = context.CompilationProvider.Combine(actorDeclarations.Collect());

        // Register the main source generation output
        context.RegisterSourceOutput(compilationAndActors, Execute);
    }

    /// <summary>
    /// Generates the [GpuNativeActor] attribute source.
    /// </summary>
    private static string GenerateGpuNativeActorAttribute()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Marks an Orleans grain interface for GPU-native actor generation.
                /// The source generator will create:
                /// - Message structs for all [GpuHandler] methods
                /// - A grain implementation with ring kernel integration
                /// - DotCompute [RingKernel] handler code
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
                internal sealed class GpuNativeActorAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Gets or sets a custom name for the generated grain class.
                    /// If not specified, the grain name is derived from the interface name.
                    /// </summary>
                    public string? GrainClassName { get; set; }

                    /// <summary>
                    /// Gets or sets whether to generate CPU fallback implementations.
                    /// Default is true.
                    /// </summary>
                    public bool GenerateCpuFallback { get; set; } = true;

                    /// <summary>
                    /// Gets or sets the default maximum payload size for handlers.
                    /// Default is 228 bytes (ring kernel limit).
                    /// </summary>
                    public int DefaultMaxPayloadSize { get; set; } = 228;
                }
            }
            """;
    }

    /// <summary>
    /// Generates the [GpuHandler] attribute source.
    /// </summary>
    private static string GenerateGpuHandlerAttribute()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Marks a method on a GPU-native actor interface as a GPU handler.
                /// The generator will create message structs and kernel dispatch code for this method.
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                internal sealed class GpuHandlerAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Gets or sets the handler execution mode.
                    /// Default is RequestResponse.
                    /// </summary>
                    public GpuHandlerMode Mode { get; set; } = GpuHandlerMode.RequestResponse;

                    /// <summary>
                    /// Gets or sets the maximum payload size in bytes.
                    /// Default is 228 bytes (ring kernel message limit).
                    /// </summary>
                    public int MaxPayloadSize { get; set; } = 228;

                    /// <summary>
                    /// Gets or sets the queue depth for message buffering.
                    /// Default is 1024.
                    /// </summary>
                    public int QueueDepth { get; set; } = 1024;

                    /// <summary>
                    /// Gets or sets whether chunking is enabled for large payloads.
                    /// When enabled, array parameters are automatically chunked.
                    /// </summary>
                    public bool EnableChunking { get; set; } = false;

                    /// <summary>
                    /// Gets or sets an optional custom kernel name.
                    /// If not specified, derived from method name.
                    /// </summary>
                    public string? KernelName { get; set; }
                }
            }
            """;
    }

    /// <summary>
    /// Generates the [GpuState] attribute source.
    /// </summary>
    private static string GenerateGpuStateAttribute()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Marks a property on a GPU-native actor interface as GPU-resident state.
                /// The state will be stored in GPU memory and accessible from kernel handlers.
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
                internal sealed class GpuStateAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Gets or sets whether the state should be persisted to grain storage.
                    /// Default is true.
                    /// </summary>
                    public bool Persist { get; set; } = true;

                    /// <summary>
                    /// Gets or sets an optional initial value expression for the state.
                    /// </summary>
                    public string? InitialValue { get; set; }

                    /// <summary>
                    /// Gets or sets whether the state is read-only from GPU handlers.
                    /// Default is false.
                    /// </summary>
                    public bool ReadOnly { get; set; } = false;
                }
            }
            """;
    }

    /// <summary>
    /// Generates the [K2KTarget] attribute source.
    /// </summary>
    private static string GenerateK2KTargetAttribute()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Marks a handler method as having a kernel-to-kernel (K2K) target.
                /// K2K enables direct GPU-to-GPU messaging without CPU involvement.
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true, Inherited = false)]
                internal sealed class K2KTargetAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Initializes a new K2K target.
                    /// </summary>
                    /// <param name="targetActorType">The target actor interface type.</param>
                    /// <param name="targetMethod">The target method name.</param>
                    public K2KTargetAttribute(global::System.Type targetActorType, string targetMethod)
                    {
                        TargetActorType = targetActorType;
                        TargetMethod = targetMethod;
                    }

                    /// <summary>
                    /// Gets the target actor interface type.
                    /// </summary>
                    public global::System.Type TargetActorType { get; }

                    /// <summary>
                    /// Gets the target method name.
                    /// </summary>
                    public string TargetMethod { get; }

                    /// <summary>
                    /// Gets or sets whether CPU fallback is allowed if K2K path is unavailable.
                    /// Default is true.
                    /// </summary>
                    public bool AllowCpuFallback { get; set; } = true;

                    /// <summary>
                    /// Gets or sets the K2K routing strategy.
                    /// Default is Direct.
                    /// </summary>
                    public K2KRoutingStrategy RoutingStrategy { get; set; } = K2KRoutingStrategy.Direct;
                }
            }
            """;
    }

    /// <summary>
    /// Generates the [TemporalOrdered] attribute source.
    /// </summary>
    private static string GenerateTemporalOrderedAttribute()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Marks a GPU-native actor interface as requiring temporal ordering.
                /// Enables GPU-side HLC (Hybrid Logical Clock) or Vector Clock maintenance.
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
                internal sealed class TemporalOrderedAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Gets or sets the temporal clock type.
                    /// Default is HLC (Hybrid Logical Clock).
                    /// </summary>
                    public TemporalClockType ClockType { get; set; } = TemporalClockType.HLC;

                    /// <summary>
                    /// Gets or sets whether strict causal ordering is enforced.
                    /// Default is false for better performance.
                    /// </summary>
                    public bool StrictOrdering { get; set; } = false;

                    /// <summary>
                    /// Gets or sets the maximum allowed clock drift in milliseconds.
                    /// Default is 100ms.
                    /// </summary>
                    public int MaxClockDriftMs { get; set; } = 100;

                    /// <summary>
                    /// Gets or sets the maximum vector clock size for VectorClock mode.
                    /// Default is 16 nodes.
                    /// </summary>
                    public int MaxVectorClockSize { get; set; } = 16;
                }
            }
            """;
    }

    /// <summary>
    /// Generates the GpuHandlerMode enum source.
    /// </summary>
    private static string GenerateGpuHandlerModeEnum()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Specifies the execution mode for GPU handlers.
                /// </summary>
                internal enum GpuHandlerMode
                {
                    /// <summary>
                    /// Request-response mode: caller waits for result.
                    /// </summary>
                    RequestResponse = 0,

                    /// <summary>
                    /// Fire-and-forget mode: caller does not wait for completion.
                    /// </summary>
                    FireAndForget = 1,

                    /// <summary>
                    /// Streaming mode: results are streamed back in chunks.
                    /// </summary>
                    Streaming = 2
                }
            }
            """;
    }

    /// <summary>
    /// Generates the K2KRoutingStrategy enum source.
    /// </summary>
    private static string GenerateK2KRoutingStrategyEnum()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Specifies the routing strategy for K2K messaging.
                /// </summary>
                internal enum K2KRoutingStrategy
                {
                    /// <summary>
                    /// Direct point-to-point messaging.
                    /// </summary>
                    Direct = 0,

                    /// <summary>
                    /// Broadcast to all actors of the target type.
                    /// </summary>
                    Broadcast = 1,

                    /// <summary>
                    /// Ring-based routing through a chain of actors.
                    /// </summary>
                    Ring = 2,

                    /// <summary>
                    /// Hash-based routing based on message content.
                    /// </summary>
                    HashRouted = 3
                }
            }
            """;
    }

    /// <summary>
    /// Generates the TemporalClockType enum source.
    /// </summary>
    private static string GenerateTemporalClockTypeEnum()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace Orleans.GpuBridge.Abstractions.Generation
            {
                /// <summary>
                /// Specifies the type of temporal clock for ordering.
                /// </summary>
                internal enum TemporalClockType
                {
                    /// <summary>
                    /// Hybrid Logical Clock - combines physical and logical time.
                    /// Best for most use cases with low overhead.
                    /// </summary>
                    HLC = 0,

                    /// <summary>
                    /// Vector Clock - tracks causality across multiple nodes.
                    /// Higher overhead but stronger ordering guarantees.
                    /// </summary>
                    VectorClock = 1,

                    /// <summary>
                    /// Lamport Clock - simple logical clock.
                    /// Lowest overhead but weaker guarantees.
                    /// </summary>
                    Lamport = 2
                }
            }
            """;
    }

    /// <summary>
    /// Quick syntactic check to see if a node might be a GPU native actor interface.
    /// </summary>
    private static bool IsCandidateInterface(SyntaxNode node)
    {
        // Quick check: must be an interface with at least one attribute
        if (node is not InterfaceDeclarationSyntax interfaceDecl)
        {
            return false;
        }

        // Must have at least one attribute list
        return interfaceDecl.AttributeLists.Count > 0;
    }

    /// <summary>
    /// Transforms an interface declaration into GPU actor info if it has [GpuNativeActor].
    /// </summary>
    private static GpuActorInfo? GetActorInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var interfaceDecl = (InterfaceDeclarationSyntax)context.Node;
        return ActorInterfaceAnalyzer.AnalyzeInterface(interfaceDecl, context.SemanticModel, cancellationToken);
    }

    /// <summary>
    /// Main execution method that generates source code for all discovered actors.
    /// </summary>
    private static void Execute(
        SourceProductionContext context,
        (Compilation Compilation, ImmutableArray<GpuActorInfo> Actors) input)
    {
        var (compilation, actors) = input;

        if (actors.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var actor in actors)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            try
            {
                // Validate the actor and report any diagnostics
                var diagnostics = ValidateActor(actor);
                foreach (var diagnostic in diagnostics)
                {
                    context.ReportDiagnostic(diagnostic);
                }

                // If there are errors, skip code generation
                if (diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error))
                {
                    continue;
                }

                // Generate message structs
                var messageStructs = MessageStructBuilder.GenerateMessageStructs(actor);
                context.AddSource(
                    $"{actor.InterfaceName}.Messages.g.cs",
                    SourceText.From(messageStructs, Encoding.UTF8));

                // Generate grain implementation
                var grainImpl = GrainImplementationBuilder.GenerateGrainClass(actor);
                context.AddSource(
                    $"{actor.InterfaceName}.Grain.g.cs",
                    SourceText.From(grainImpl, Encoding.UTF8));

                // Generate kernel code
                var kernelCode = KernelCodeBuilder.GenerateKernelCode(actor);
                context.AddSource(
                    $"{actor.InterfaceName}.Kernels.g.cs",
                    SourceText.From(kernelCode, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    DiagnosticDescriptors.InternalError,
                    actor.Location,
                    ex.Message));
            }
        }
    }

    /// <summary>
    /// Validates an actor and returns any diagnostics.
    /// </summary>
    private static ImmutableArray<Diagnostic> ValidateActor(GpuActorInfo actor)
    {
        var diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();

        // Check for missing grain interface
        if (actor.KeyType == GrainKeyType.Unknown)
        {
            diagnostics.Add(Diagnostic.Create(
                DiagnosticDescriptors.MissingGrainInterface,
                actor.Location,
                actor.InterfaceName));
        }

        // Check for no handlers
        if (actor.Handlers.IsDefaultOrEmpty || actor.Handlers.Length == 0)
        {
            diagnostics.Add(Diagnostic.Create(
                DiagnosticDescriptors.NoHandlersDefined,
                actor.Location,
                actor.InterfaceName));
        }

        // Validate each handler
        foreach (var handler in actor.Handlers)
        {
            ValidateHandler(handler, diagnostics);
        }

        // Validate state properties
        foreach (var state in actor.StateProperties)
        {
            if (!state.IsBlittable)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.NonBlittableState,
                    actor.Location,
                    state.Name,
                    state.TypeName));
            }
        }

        return diagnostics.ToImmutable();
    }

    /// <summary>
    /// Validates a handler method.
    /// </summary>
    private static void ValidateHandler(GpuHandlerInfo handler, ImmutableArray<Diagnostic>.Builder diagnostics)
    {
        // Check for non-blittable parameters
        foreach (var param in handler.Parameters)
        {
            if (!param.IsBlittable && !param.IsArray)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.NonBlittableParameter,
                    handler.Location,
                    param.Name,
                    param.TypeName,
                    handler.MethodName));
            }

            // Check for arrays without chunking
            if (param.IsArray && !handler.EnableChunking)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.ChunkingRequired,
                    handler.Location,
                    handler.MethodName,
                    param.TypeName));
            }
        }

        // Check payload size
        if (handler.RequestMessageSize > handler.MaxPayloadSize && !handler.EnableChunking)
        {
            diagnostics.Add(Diagnostic.Create(
                DiagnosticDescriptors.PayloadExceedsMaxSize,
                handler.Location,
                handler.MethodName,
                handler.RequestMessageSize,
                handler.MaxPayloadSize));
        }
    }
}
