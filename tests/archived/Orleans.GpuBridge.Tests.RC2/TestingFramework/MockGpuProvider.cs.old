using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Orleans.GpuBridge.Abstractions;
using Orleans.GpuBridge.Abstractions.Enums;
using Orleans.GpuBridge.Abstractions.Models;
using Orleans.GpuBridge.Abstractions.Providers;
using Orleans.GpuBridge.Abstractions.Providers.Execution.Interfaces;
using Orleans.GpuBridge.Abstractions.Providers.Execution.Parameters;
using Orleans.GpuBridge.Abstractions.Providers.Execution.Results;
using Orleans.GpuBridge.Abstractions.Providers.Memory.Allocators;
using Orleans.GpuBridge.Abstractions.Providers.Memory.Interfaces;

namespace Orleans.GpuBridge.Tests.RC2.TestingFramework;

/// <summary>
/// Mock GPU backend provider for testing without hardware dependencies.
/// Simulates GPU operations including allocation, execution, and DMA transfers.
/// Provides configurable behavior for testing success, failure, and timeout scenarios.
/// </summary>
/// <remarks>
/// This mock provider allows testing GPU Bridge functionality without requiring
/// actual GPU hardware. It tracks all operations for verification and supports
/// configurable delays, failures, and metrics collection. Thread-safe for concurrent testing.
/// </remarks>
public sealed class MockGpuProvider : IGpuBackendProvider
{
    private readonly object _lock = new();
    private readonly ConcurrentDictionary<IntPtr, MockDeviceMemory> _allocations = new();
    private readonly ConcurrentDictionary<string, int> _executionCounts = new();
    private bool _disposed;
    private bool _initialized;

    /// <summary>
    /// Gets the unique provider identifier.
    /// </summary>
    public string ProviderId => "mock-gpu";

    /// <summary>
    /// Gets the display name of the mock provider.
    /// </summary>
    public string DisplayName => "Mock GPU Provider";

    /// <summary>
    /// Gets the version of the mock provider.
    /// </summary>
    public Version Version => new(1, 0, 0);

    /// <summary>
    /// Gets the capabilities of the mock provider.
    /// </summary>
    public BackendCapabilities Capabilities { get; }

    /// <summary>
    /// Gets or sets whether the provider should simulate failures.
    /// When true, operations will throw exceptions to test error handling.
    /// </summary>
    public bool SimulateFailure { get; set; }

    /// <summary>
    /// Gets or sets the simulated delay for operations.
    /// Useful for testing timeout and cancellation scenarios.
    /// </summary>
    public TimeSpan SimulatedDelay { get; set; } = TimeSpan.Zero;

    /// <summary>
    /// Gets or sets the probability (0.0 to 1.0) of random failures.
    /// Allows testing of intermittent failure scenarios.
    /// </summary>
    public double FailureProbability { get; set; }

    /// <summary>
    /// Gets or sets whether to track detailed metrics.
    /// When true, records all operations for later verification.
    /// </summary>
    public bool TrackMetrics { get; set; } = true;

    /// <summary>
    /// Gets the total number of memory allocations performed.
    /// </summary>
    public int AllocationCount { get; private set; }

    /// <summary>
    /// Gets the total number of kernel executions performed.
    /// </summary>
    public int ExecutionCount => _executionCounts.Values.Sum();

    /// <summary>
    /// Gets the total bytes allocated in device memory.
    /// </summary>
    public long TotalBytesAllocated { get; private set; }

    /// <summary>
    /// Gets the mock device manager.
    /// </summary>
    private readonly MockDeviceManager _deviceManager;

    /// <summary>
    /// Gets the mock kernel compiler.
    /// </summary>
    private readonly MockKernelCompiler _kernelCompiler;

    /// <summary>
    /// Gets the mock memory allocator.
    /// </summary>
    private readonly MockMemoryAllocator _memoryAllocator;

    /// <summary>
    /// Gets the mock kernel executor.
    /// </summary>
    private readonly MockKernelExecutor _kernelExecutor;

    /// <summary>
    /// Initializes a new instance of the <see cref="MockGpuProvider"/> class.
    /// </summary>
    public MockGpuProvider()
    {
        Capabilities = BackendCapabilities.CreateCpuFallback();
        _deviceManager = new MockDeviceManager(this);
        _kernelCompiler = new MockKernelCompiler(this);
        _memoryAllocator = new MockMemoryAllocator(this);
        _kernelExecutor = new MockKernelExecutor(this);
    }

    /// <summary>
    /// Initializes the mock provider asynchronously.
    /// </summary>
    /// <param name="configuration">Backend configuration.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    public async Task InitializeAsync(BackendConfiguration configuration, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        await SimulateDelayAsync(cancellationToken).ConfigureAwait(false);
        ThrowIfSimulatingFailure();

        lock (_lock)
        {
            _initialized = true;
        }
    }

    /// <summary>
    /// Checks if the mock provider is available (always returns true).
    /// </summary>
    public async Task<bool> IsAvailableAsync(CancellationToken cancellationToken = default)
    {
        await SimulateDelayAsync(cancellationToken).ConfigureAwait(false);
        return !SimulateFailure;
    }

    /// <summary>
    /// Checks if the mock provider is available synchronously.
    /// </summary>
    public bool IsAvailable() => !SimulateFailure;

    /// <summary>
    /// Gets the device manager for this provider.
    /// </summary>
    public IDeviceManager GetDeviceManager()
    {
        ThrowIfDisposed();
        return _deviceManager;
    }

    /// <summary>
    /// Gets the kernel compiler for this provider.
    /// </summary>
    public IKernelCompiler GetKernelCompiler()
    {
        ThrowIfDisposed();
        return _kernelCompiler;
    }

    /// <summary>
    /// Gets the memory allocator for this provider.
    /// </summary>
    public IMemoryAllocator GetMemoryAllocator()
    {
        ThrowIfDisposed();
        return _memoryAllocator;
    }

    /// <summary>
    /// Gets the kernel executor for this provider.
    /// </summary>
    public IKernelExecutor GetKernelExecutor()
    {
        ThrowIfDisposed();
        return _kernelExecutor;
    }

    /// <summary>
    /// Gets backend-specific metrics.
    /// </summary>
    public async Task<IReadOnlyDictionary<string, object>> GetMetricsAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        await SimulateDelayAsync(cancellationToken).ConfigureAwait(false);

        return new Dictionary<string, object>
        {
            ["AllocationCount"] = AllocationCount,
            ["ExecutionCount"] = ExecutionCount,
            ["TotalBytesAllocated"] = TotalBytesAllocated,
            ["ActiveAllocations"] = _allocations.Count,
            ["ExecutionBreakdown"] = new Dictionary<string, int>(_executionCounts)
        };
    }

    /// <summary>
    /// Performs a health check on the mock provider.
    /// </summary>
    public async Task<HealthCheckResult> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        await SimulateDelayAsync(cancellationToken).ConfigureAwait(false);

        var isHealthy = _initialized && !SimulateFailure;
        var diagnostics = new Dictionary<string, object>
        {
            ["Initialized"] = _initialized,
            ["AllocationCount"] = AllocationCount,
            ["ExecutionCount"] = ExecutionCount
        };

        return new HealthCheckResult(
            isHealthy,
            isHealthy ? "Mock provider is healthy" : "Mock provider is unhealthy or not initialized",
            diagnostics);
    }

    /// <summary>
    /// Creates a mock compute context.
    /// </summary>
    public async Task<object> CreateContext(int deviceIndex = 0)
    {
        ThrowIfDisposed();
        await SimulateDelayAsync(default).ConfigureAwait(false);
        return new { DeviceIndex = deviceIndex, Type = "Mock" };
    }

    /// <summary>
    /// Records a memory allocation for tracking.
    /// </summary>
    internal void RecordAllocation(long sizeBytes, IntPtr pointer)
    {
        if (!TrackMetrics) return;

        lock (_lock)
        {
            AllocationCount++;
            TotalBytesAllocated += sizeBytes;
        }

        _allocations.TryAdd(pointer, new MockDeviceMemory(pointer, sizeBytes, this));
    }

    /// <summary>
    /// Records a memory deallocation for tracking.
    /// </summary>
    internal void RecordDeallocation(IntPtr pointer)
    {
        if (!TrackMetrics) return;

        if (_allocations.TryRemove(pointer, out var memory))
        {
            lock (_lock)
            {
                TotalBytesAllocated -= memory.SizeBytes;
            }
        }
    }

    /// <summary>
    /// Records a kernel execution for tracking.
    /// </summary>
    internal void RecordExecution(string kernelName)
    {
        if (!TrackMetrics) return;

        _executionCounts.AddOrUpdate(kernelName, 1, (_, count) => count + 1);
    }

    /// <summary>
    /// Resets all tracked metrics and configuration to default state.
    /// </summary>
    public void Reset()
    {
        lock (_lock)
        {
            AllocationCount = 0;
            TotalBytesAllocated = 0;
            SimulateFailure = false;
            SimulatedDelay = TimeSpan.Zero;
            FailureProbability = 0;
        }

        _allocations.Clear();
        _executionCounts.Clear();
    }

    /// <summary>
    /// Gets the number of executions for a specific kernel.
    /// </summary>
    public int GetExecutionCount(string kernelName)
    {
        return _executionCounts.TryGetValue(kernelName, out var count) ? count : 0;
    }

    /// <summary>
    /// Disposes the mock provider and cleans up resources.
    /// </summary>
    public void Dispose()
    {
        if (_disposed) return;

        lock (_lock)
        {
            if (_disposed) return;
            _disposed = true;
        }

        foreach (var allocation in _allocations.Values)
        {
            allocation.Dispose();
        }

        _allocations.Clear();
        _executionCounts.Clear();
    }

    private async Task SimulateDelayAsync(CancellationToken cancellationToken)
    {
        if (SimulatedDelay > TimeSpan.Zero)
        {
            await Task.Delay(SimulatedDelay, cancellationToken).ConfigureAwait(false);
        }
    }

    private void ThrowIfSimulatingFailure()
    {
        if (SimulateFailure || (FailureProbability > 0 && Random.Shared.NextDouble() < FailureProbability))
        {
            throw new InvalidOperationException("Simulated GPU provider failure");
        }
    }

    private void ThrowIfDisposed()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
    }

    /// <summary>
    /// Mock device memory implementation.
    /// </summary>
    private sealed class MockDeviceMemory : IDeviceMemory
    {
        private readonly MockGpuProvider _provider;
        private bool _disposed;

        public long SizeBytes { get; }
        public IntPtr DevicePointer { get; }
        public IComputeDevice Device => _provider._deviceManager.GetDefaultDevice();

        public MockDeviceMemory(IntPtr pointer, long sizeBytes, MockGpuProvider provider)
        {
            DevicePointer = pointer;
            SizeBytes = sizeBytes;
            _provider = provider;
        }

        public Task CopyFromHostAsync(IntPtr hostPointer, long offsetBytes, long sizeBytes, CancellationToken cancellationToken = default)
        {
            return _provider.SimulateDelayAsync(cancellationToken);
        }

        public Task CopyToHostAsync(IntPtr hostPointer, long offsetBytes, long sizeBytes, CancellationToken cancellationToken = default)
        {
            return _provider.SimulateDelayAsync(cancellationToken);
        }

        public Task CopyFromAsync(IDeviceMemory source, long sourceOffset, long destinationOffset, long sizeBytes, CancellationToken cancellationToken = default)
        {
            return _provider.SimulateDelayAsync(cancellationToken);
        }

        public Task FillAsync(byte value, long offsetBytes, long sizeBytes, CancellationToken cancellationToken = default)
        {
            return _provider.SimulateDelayAsync(cancellationToken);
        }

        public IDeviceMemory CreateView(long offsetBytes, long sizeBytes)
        {
            return new MockDeviceMemory(DevicePointer + (int)offsetBytes, sizeBytes, _provider);
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
            _provider.RecordDeallocation(DevicePointer);
        }
    }

    /// <summary>
    /// Mock device manager implementation (nested classes continue in next section).
    /// </summary>
    private sealed class MockDeviceManager : IDeviceManager
    {
        private readonly MockGpuProvider _provider;
        private readonly List<IComputeDevice> _devices;
        private bool _disposed;

        public MockDeviceManager(MockGpuProvider provider)
        {
            _provider = provider;
            _devices = new List<IComputeDevice>
            {
                new MockComputeDevice("mock-device-0", 0, "Mock GPU 0", provider)
            };
        }

        public Task InitializeAsync(CancellationToken cancellationToken = default)
        {
            return _provider.SimulateDelayAsync(cancellationToken);
        }

        public IReadOnlyList<IComputeDevice> GetDevices() => _devices;

        public IComputeDevice? GetDevice(int deviceIndex)
        {
            return deviceIndex >= 0 && deviceIndex < _devices.Count ? _devices[deviceIndex] : null;
        }

        public IComputeDevice GetDefaultDevice() => _devices[0];

        public IComputeDevice SelectDevice(DeviceSelectionCriteria criteria) => _devices[0];

        public Task<IComputeContext> CreateContextAsync(IComputeDevice device, ContextOptions options, CancellationToken cancellationToken = default)
        {
            return Task.FromResult<IComputeContext>(new MockComputeContext());
        }

        public Task<DeviceMetrics> GetDeviceMetricsAsync(IComputeDevice device, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(new DeviceMetrics(
                TotalMemoryBytes: 1024L * 1024 * 1024,
                AvailableMemoryBytes: 512L * 1024 * 1024,
                Utilization: 0.5,
                Temperature: 65.0));
        }

        public Task ResetDeviceAsync(IComputeDevice device, CancellationToken cancellationToken = default)
        {
            return _provider.SimulateDelayAsync(cancellationToken);
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
        }
    }

    private sealed class MockComputeDevice : IComputeDevice
    {
        private readonly MockGpuProvider _provider;

        public string DeviceId { get; }
        public int Index { get; }
        public string Name { get; }
        public DeviceType Type => DeviceType.GPU;
        public string Vendor => "Mock";
        public string Architecture => "MockArch";
        public Version ComputeCapability => new(5, 0);
        public long TotalMemoryBytes => 1024L * 1024 * 1024;
        public long AvailableMemoryBytes => 512L * 1024 * 1024;
        public int ComputeUnits => 16;
        public int MaxClockFrequencyMHz => 1500;
        public int MaxThreadsPerBlock => 1024;
        public int[] MaxWorkGroupDimensions => new[] { 1024, 1024, 64 };
        public int WarpSize => 32;
        public IReadOnlyDictionary<string, object> Properties => new Dictionary<string, object>();

        public MockComputeDevice(string deviceId, int index, string name, MockGpuProvider provider)
        {
            DeviceId = deviceId;
            Index = index;
            Name = name;
            _provider = provider;
        }

        public bool SupportsFeature(string feature) => true;
        public DeviceStatus GetStatus() => DeviceStatus.Available;
    }

    private sealed class MockComputeContext : IComputeContext
    {
        public void Dispose() { }
    }

    private sealed class MockKernelCompiler : IKernelCompiler
    {
        private readonly MockGpuProvider _provider;

        public MockKernelCompiler(MockGpuProvider provider)
        {
            _provider = provider;
        }

        public Task<CompiledKernel> CompileAsync(string kernelSource, KernelCompilationOptions options, CancellationToken cancellationToken = default)
        {
            var kernel = new CompiledKernel { Name = options.KernelName };
            return Task.FromResult(kernel);
        }

        public Task<bool> ValidateAsync(string kernelSource, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(true);
        }
    }

    private sealed class MockMemoryAllocator : IMemoryAllocator
    {
        private readonly MockGpuProvider _provider;

        public MockMemoryAllocator(MockGpuProvider provider)
        {
            _provider = provider;
        }

        public Task<IDeviceMemory> AllocateAsync(long sizeBytes, MemoryAllocationOptions options, CancellationToken cancellationToken = default)
        {
            var pointer = new IntPtr(_provider.AllocationCount + 1);
            _provider.RecordAllocation(sizeBytes, pointer);
            return Task.FromResult<IDeviceMemory>(new MockDeviceMemory(pointer, sizeBytes, _provider));
        }

        public Task<IDeviceMemory> AllocateAsync(IComputeDevice device, long sizeBytes, CancellationToken cancellationToken = default)
        {
            return AllocateAsync(sizeBytes, new MemoryAllocationOptions(), cancellationToken);
        }

        public Task FreeAsync(IDeviceMemory memory, CancellationToken cancellationToken = default)
        {
            memory.Dispose();
            return Task.CompletedTask;
        }

        public Task<MemoryPoolStatistics> GetStatisticsAsync(CancellationToken cancellationToken = default)
        {
            return Task.FromResult(new MemoryPoolStatistics(
                TotalAllocated: _provider.TotalBytesAllocated,
                TotalFreed: 0,
                ActiveAllocations: _provider.AllocationCount,
                PeakMemoryUsage: _provider.TotalBytesAllocated));
        }
    }

    private sealed class MockKernelExecutor : IKernelExecutor
    {
        private readonly MockGpuProvider _provider;

        public MockKernelExecutor(MockGpuProvider provider)
        {
            _provider = provider;
        }

        public async Task<KernelExecutionResult> ExecuteAsync(CompiledKernel kernel, KernelExecutionParameters parameters, CancellationToken cancellationToken = default)
        {
            await _provider.SimulateDelayAsync(cancellationToken).ConfigureAwait(false);
            _provider.ThrowIfSimulatingFailure();
            _provider.RecordExecution(kernel.Name);

            return new KernelExecutionResult(
                Success: true,
                ExecutionTimeMs: _provider.SimulatedDelay.TotalMilliseconds,
                KernelName: kernel.Name);
        }

        public Task<IKernelExecution> ExecuteAsyncNonBlocking(CompiledKernel kernel, KernelExecutionParameters parameters, CancellationToken cancellationToken = default)
        {
            return Task.FromResult<IKernelExecution>(new MockKernelExecution());
        }

        public Task<BatchExecutionResult> ExecuteBatchAsync(IReadOnlyList<KernelBatchItem> batch, BatchExecutionOptions options, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(new BatchExecutionResult(Success: true, CompletedCount: batch.Count));
        }

        public IKernelGraph CreateGraph(string graphName) => new MockKernelGraph();

        public Task<KernelProfile> ProfileAsync(CompiledKernel kernel, KernelExecutionParameters parameters, int iterations = 100, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(new KernelProfile(KernelName: kernel.Name, Iterations: iterations));
        }

        public ExecutionStatistics GetStatistics() => new();
        public void ResetStatistics() { }
    }

    private sealed class MockKernelExecution : IKernelExecution
    {
        public Task WaitAsync(CancellationToken cancellationToken = default) => Task.CompletedTask;
        public void Dispose() { }
    }

    private sealed class MockKernelGraph : IKernelGraph
    {
        public void Dispose() { }
    }
}
