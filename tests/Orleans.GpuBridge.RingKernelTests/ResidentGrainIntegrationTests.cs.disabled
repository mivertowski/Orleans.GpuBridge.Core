using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Orleans;
using Orleans.Hosting;
using Orleans.TestingHost;
using Orleans.GpuBridge.Abstractions;
using Orleans.GpuBridge.Abstractions.Providers;
using Orleans.GpuBridge.Grains;
using Orleans.GpuBridge.Grains.Enums;
using Orleans.GpuBridge.Grains.Models;
using Orleans.GpuBridge.Grains.Resident;
using Orleans.GpuBridge.Runtime.Providers;
using Xunit;
using Xunit.Abstractions;

namespace Orleans.GpuBridge.RingKernelTests;

/// <summary>
/// Integration tests for GpuResidentGrain with Orleans TestingHost.
/// Tests grain lifecycle, message processing, and Ring Kernel integration.
/// </summary>
public class ResidentGrainIntegrationTests : IDisposable
{
    private readonly TestCluster _cluster;
    private readonly ITestOutputHelper _output;

    public ResidentGrainIntegrationTests(ITestOutputHelper output)
    {
        _output = output;

        // Configure Orleans TestingHost with DotCompute backend
        var builder = new TestClusterBuilder();

        builder.AddSiloBuilderConfigurator<TestSiloConfigurator>();

        _cluster = builder.Build();
        _cluster.Deploy();

        _output.WriteLine("✅ Orleans TestingHost cluster started");
    }

    private class TestSiloConfigurator : ISiloConfigurator
    {
        public void Configure(ISiloBuilder siloBuilder)
        {
            siloBuilder.ConfigureServices(services =>
            {
                // Register DotCompute backend provider
                services.AddSingleton<IGpuBackendProvider>(sp =>
                {
                    var logger = sp.GetRequiredService<ILogger<GpuBackendRegistry>>();
                    var registry = new GpuBackendRegistry(logger);

                    // Try to get DotCompute provider (will use CPU fallback if not available)
                    var provider = registry.GetProviderAsync("DotCompute", default).GetAwaiter().GetResult();
                    return provider ?? throw new InvalidOperationException("No GPU backend provider available");
                });

                // Configure GPU bridge options
                services.Configure<GpuBridgeOptions>(options =>
                {
                    options.PreferGpu = true;
                    options.EnableMetrics = true;
                });
            });
        }
    }

    [Fact]
    public async Task GrainActivation_ShouldInitializeRingKernel()
    {
        // Arrange
        var grain = _cluster.GrainFactory.GetGrain<IGpuResidentGrain<float>>(Guid.NewGuid());

        // Act - Activate grain by calling an operation
        var handle = await grain.AllocateAsync(1024 * 1024); // 1MB allocation

        // Assert
        Assert.NotNull(handle);
        Assert.NotEqual(Guid.Empty, Guid.Parse(handle.Id));
        Assert.Equal(1024 * 1024, handle.SizeBytes);

        _output.WriteLine($"✅ Grain activated with allocation: {handle.Id}");
        _output.WriteLine($"   Size: {handle.SizeBytes:N0} bytes");
        _output.WriteLine($"   Type: {handle.Type}");
    }

    [Fact]
    public async Task AllocateAsync_ShouldTrackPoolHits()
    {
        // Arrange
        var grain = _cluster.GrainFactory.GetGrain<IGpuResidentGrain<float>>(Guid.NewGuid());

        // Act - Allocate same size multiple times to test pool
        var handle1 = await grain.AllocateAsync(4096);
        await grain.ReleaseAsync(handle1, returnToPool: true);

        var handle2 = await grain.AllocateAsync(4096); // Should be pool hit
        await grain.ReleaseAsync(handle2, returnToPool: true);

        var handle3 = await grain.AllocateAsync(4096); // Should be pool hit

        var metrics = await grain.GetMetricsAsync();

        // Assert
        Assert.NotNull(metrics);
        _output.WriteLine($"✅ Memory pool tested with {metrics.PoolHitCount} hits, {metrics.PoolMissCount} misses");
        _output.WriteLine($"   Pool hit rate: {metrics.PoolHitRate:P2}");
        _output.WriteLine($"   Total allocations: {metrics.ActiveAllocationCount}");

        // We should have at least 1 pool hit from the second allocation
        Assert.True(metrics.PoolHitCount > 0, "Expected at least one pool hit");
    }

    [Fact]
    public async Task WriteReadAsync_ShouldTransferDataCorrectly()
    {
        // Arrange
        var grain = _cluster.GrainFactory.GetGrain<IGpuResidentGrain<float>>(Guid.NewGuid());
        var handle = await grain.AllocateAsync(1024 * sizeof(float)); // 1K floats

        var testData = Enumerable.Range(0, 1024).Select(i => (float)i).ToArray();

        // Act - Write data
        var sw = Stopwatch.StartNew();
        await grain.WriteAsync(handle, testData);
        sw.Stop();
        var writeTimeUs = sw.Elapsed.TotalMicroseconds;

        // Act - Read data back
        sw.Restart();
        var readData = await grain.ReadAsync(handle, 0, 1024);
        sw.Stop();
        var readTimeUs = sw.Elapsed.TotalMicroseconds;

        // Assert
        Assert.NotNull(readData);
        Assert.Equal(1024, readData.Length);

        // Verify data integrity (spot check)
        Assert.Equal(0f, readData[0]);
        Assert.Equal(512f, readData[512]);
        Assert.Equal(1023f, readData[1023]);

        _output.WriteLine($"✅ DMA transfer validated");
        _output.WriteLine($"   Write: {writeTimeUs:F2} μs ({testData.Length * sizeof(float)} bytes)");
        _output.WriteLine($"   Read:  {readTimeUs:F2} μs ({readData.Length * sizeof(float)} bytes)");
        _output.WriteLine($"   Bandwidth: {(testData.Length * sizeof(float) / writeTimeUs):F2} MB/s (write)");

        // Cleanup
        await grain.ReleaseAsync(handle);
    }

    [Fact]
    public async Task MetricsAsync_ShouldReturnComprehensiveData()
    {
        // Arrange
        var grain = _cluster.GrainFactory.GetGrain<IGpuResidentGrain<float>>(Guid.NewGuid());

        // Perform some operations to generate metrics
        var handle1 = await grain.AllocateAsync(2048);
        var handle2 = await grain.AllocateAsync(4096);
        await grain.WriteAsync(handle1, new float[] { 1.0f, 2.0f, 3.0f });

        // Act
        var metrics = await grain.GetMetricsAsync();

        // Assert
        Assert.NotNull(metrics);
        Assert.True(metrics.ActiveAllocationCount >= 2);
        Assert.True(metrics.TotalAllocatedBytes >= 6144); // 2048 + 4096

        _output.WriteLine($"✅ Comprehensive metrics collected:");
        _output.WriteLine($"   Active allocations: {metrics.ActiveAllocationCount}");
        _output.WriteLine($"   Total memory: {metrics.TotalMemoryMB:F2} MB");
        _output.WriteLine($"   Pool hit rate: {metrics.PoolHitRate:P2}");
        _output.WriteLine($"   Memory efficiency: {metrics.MemoryEfficiency:P2}");
        _output.WriteLine($"   Kernel cache size: {metrics.KernelCacheSize}");
        _output.WriteLine($"   Kernel cache hit rate: {metrics.KernelCacheHitRate:P2}");
        _output.WriteLine($"   Uptime: {metrics.Uptime.TotalSeconds:F2} seconds");
        _output.WriteLine($"   Device: {metrics.DeviceType} - {metrics.DeviceName}");

        // Cleanup
        await grain.ReleaseAsync(handle1);
        await grain.ReleaseAsync(handle2);
    }

    [Fact]
    public async Task GrainDeactivation_ShouldCleanupResources()
    {
        // Arrange
        var grainId = Guid.NewGuid();
        var grain = _cluster.GrainFactory.GetGrain<IGpuResidentGrain<float>>(grainId);

        // Create some allocations
        var handle1 = await grain.AllocateAsync(1024);
        var handle2 = await grain.AllocateAsync(2048);

        var metricsBeforeDeactivation = await grain.GetMetricsAsync();
        Assert.Equal(2, metricsBeforeDeactivation.ActiveAllocationCount);

        // Act - Force deactivation by accessing a new grain instance
        // (Orleans will eventually deactivate the old one)
        await Task.Delay(100); // Give some time for operations to complete

        // Note: In a real test, we'd need to wait for deactivation or trigger it explicitly
        // For now, we just verify the grain is functioning
        _output.WriteLine($"✅ Grain lifecycle tested");
        _output.WriteLine($"   Allocations before deactivation: {metricsBeforeDeactivation.ActiveAllocationCount}");
        _output.WriteLine($"   Total memory: {metricsBeforeDeactivation.TotalMemoryMB:F2} MB");

        // Cleanup
        await grain.ReleaseAsync(handle1);
        await grain.ReleaseAsync(handle2);
    }

    [Fact]
    public async Task ConcurrentAllocations_ShouldBeThreadSafe()
    {
        // Arrange
        var grain = _cluster.GrainFactory.GetGrain<IGpuResidentGrain<float>>(Guid.NewGuid());
        const int concurrentOps = 100;

        // Act - Perform concurrent allocations
        var sw = Stopwatch.StartNew();
        var tasks = Enumerable.Range(0, concurrentOps)
            .Select(async i =>
            {
                var size = 1024 * (i % 10 + 1); // Vary sizes from 1KB to 10KB
                var handle = await grain.AllocateAsync(size);
                return handle;
            })
            .ToArray();

        var handles = await Task.WhenAll(tasks);
        sw.Stop();

        // Assert
        Assert.Equal(concurrentOps, handles.Length);
        Assert.All(handles, h => Assert.NotNull(h));

        // All handles should be unique
        var uniqueIds = handles.Select(h => h.Id).Distinct().Count();
        Assert.Equal(concurrentOps, uniqueIds);

        var metrics = await grain.GetMetricsAsync();

        _output.WriteLine($"✅ Concurrent allocations tested");
        _output.WriteLine($"   Operations: {concurrentOps}");
        _output.WriteLine($"   Total time: {sw.Elapsed.TotalMilliseconds:F2} ms");
        _output.WriteLine($"   Average: {sw.Elapsed.TotalMilliseconds / concurrentOps:F2} ms/op");
        _output.WriteLine($"   Throughput: {concurrentOps / sw.Elapsed.TotalSeconds:F0} ops/sec");
        _output.WriteLine($"   Active allocations: {metrics.ActiveAllocationCount}");
        _output.WriteLine($"   Pool hit rate: {metrics.PoolHitRate:P2}");

        // Cleanup
        foreach (var handle in handles)
        {
            await grain.ReleaseAsync(handle);
        }
    }

    public void Dispose()
    {
        _cluster?.StopAllSilos();
        _output.WriteLine("✅ Orleans TestingHost cluster stopped");
    }
}
