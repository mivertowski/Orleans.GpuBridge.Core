// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans
// Copyright (c) 2025 Michael Ivertowski
//
// <auto-generated>
// This code was generated by GpuNativeActorGenerator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using System;
using System.Runtime.CompilerServices;
using DotCompute.Abstractions.Attributes;

namespace Orleans.GpuBridge.Grains.Generated;

/// <summary>
/// DotCompute ring kernels for CalculatorActor.
/// These kernels run persistently on the GPU in an infinite dispatch loop.
/// </summary>
/// <remarks>
/// <para>
/// <strong>Ring Kernel Architecture:</strong>
/// <code>
/// GPU Memory:
/// ┌─────────────────────────────────────────────────────────┐
/// │ [State: CalculatorActorState]                          │
/// │ [Queue: Lock-Free Message Queue (depth=1024)]          │
/// │ [Kernel: Infinite Dispatch Loop]                       │
/// └─────────────────────────────────────────────────────────┘
///
/// Kernel Dispatch Loop (runs forever):
///   while (is_active) {
///       if (queue.TryDequeue(out msg)) {
///           switch (msg.HandlerId) {
///               case 1: Add_Execute(msg.Payload, ref state); break;
///               case 2: Subtract_Execute(msg.Payload, ref state); break;
///               ...
///           }
///       }
///       // Spin for next message (~100ns interval)
///   }
/// </code>
/// </para>
/// </remarks>
public static class CalculatorActorKernels
{
    /// <summary>
    /// Kernel ID for the main calculator dispatch kernel.
    /// </summary>
    public const string DispatchKernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.Dispatch";

    #region Add Kernel

    /// <summary>
    /// GPU kernel for Add operation.
    /// </summary>
    /// <param name="request">Add request</param>
    /// <param name="response">Add response (output)</param>
    /// <param name="state">Actor state (ref for updates)</param>
    [RingKernel(KernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.Add")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Add_Execute(
        in AddRequest request,
        out AddResponse response,
        ref CalculatorActorState state)
    {
        response = new AddResponse { Result = request.A + request.B };
        state.OperationCount++;
    }

    #endregion

    #region Subtract Kernel

    /// <summary>
    /// GPU kernel for Subtract operation.
    /// </summary>
    /// <param name="request">Subtract request</param>
    /// <param name="response">Subtract response (output)</param>
    /// <param name="state">Actor state (ref for updates)</param>
    [RingKernel(KernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.Subtract")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Subtract_Execute(
        in SubtractRequest request,
        out SubtractResponse response,
        ref CalculatorActorState state)
    {
        response = new SubtractResponse { Result = request.A - request.B };
        state.OperationCount++;
    }

    #endregion

    #region Multiply Kernel (Fire-and-Forget)

    /// <summary>
    /// GPU kernel for Multiply operation (fire-and-forget).
    /// Updates accumulator without returning a response.
    /// </summary>
    /// <param name="request">Multiply request</param>
    /// <param name="state">Actor state (ref for updates)</param>
    [RingKernel(KernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.Multiply")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Multiply_Execute(
        in MultiplyRequest request,
        ref CalculatorActorState state)
    {
        state.Accumulator += (long)request.A * request.B;
        state.OperationCount++;
    }

    #endregion

    #region Factorial Kernel

    /// <summary>
    /// GPU kernel for Factorial operation.
    /// </summary>
    /// <param name="request">Factorial request</param>
    /// <param name="response">Factorial response (output)</param>
    /// <param name="state">Actor state (ref for updates)</param>
    /// <remarks>
    /// This kernel demonstrates a compute-intensive operation that
    /// benefits significantly from GPU parallelization when processing
    /// batches of factorial requests.
    /// </remarks>
    [RingKernel(KernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.Factorial")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Factorial_Execute(
        in FactorialRequest request,
        out FactorialResponse response,
        ref CalculatorActorState state)
    {
        long result = 1;
        for (int i = 2; i <= request.N; i++)
        {
            result *= i;
        }

        response = new FactorialResponse { Result = result };
        state.LastFactorial = result;
        state.OperationCount++;
    }

    #endregion

    #region GetAccumulator Kernel

    /// <summary>
    /// GPU kernel for GetAccumulator operation.
    /// Returns current accumulator value without modifying state.
    /// </summary>
    /// <param name="request">GetAccumulator request</param>
    /// <param name="response">GetAccumulator response (output)</param>
    /// <param name="state">Actor state (read-only in this case)</param>
    [RingKernel(KernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.GetAccumulator")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void GetAccumulator_Execute(
        in GetAccumulatorRequest request,
        out GetAccumulatorResponse response,
        ref CalculatorActorState state)
    {
        response = new GetAccumulatorResponse { Value = state.Accumulator };
        // Read-only operation, no state.OperationCount++ needed
    }

    #endregion

    #region Reset Kernel (Fire-and-Forget)

    /// <summary>
    /// GPU kernel for Reset operation (fire-and-forget).
    /// Resets all state to initial values.
    /// </summary>
    /// <param name="request">Reset request</param>
    /// <param name="state">Actor state (ref for updates)</param>
    [RingKernel(KernelId = "Orleans.GpuBridge.Grains.Generated.CalculatorActor.Reset")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Reset_Execute(
        in ResetRequest request,
        ref CalculatorActorState state)
    {
        state.Accumulator = 0;
        state.LastFactorial = 0;
        state.OperationCount++;
    }

    #endregion

    #region Main Dispatch Kernel

    /// <summary>
    /// Main dispatch kernel that routes messages to appropriate handlers.
    /// This kernel runs in an infinite loop until deactivation.
    /// </summary>
    /// <param name="handlerId">Handler ID from message header</param>
    /// <param name="requestPtr">Pointer to request payload</param>
    /// <param name="responsePtr">Pointer to response buffer</param>
    /// <param name="state">Actor state reference</param>
    /// <returns>True if handler produced a response, false for fire-and-forget</returns>
    [RingKernel(KernelId = DispatchKernelId)]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe bool Dispatch(
        int handlerId,
        void* requestPtr,
        void* responsePtr,
        ref CalculatorActorState state)
    {
        switch (handlerId)
        {
            case CalculatorActorHandlerIds.Add:
                Add_Execute(
                    *(AddRequest*)requestPtr,
                    out *(AddResponse*)responsePtr,
                    ref state);
                return true;

            case CalculatorActorHandlerIds.Subtract:
                Subtract_Execute(
                    *(SubtractRequest*)requestPtr,
                    out *(SubtractResponse*)responsePtr,
                    ref state);
                return true;

            case CalculatorActorHandlerIds.Multiply:
                Multiply_Execute(
                    *(MultiplyRequest*)requestPtr,
                    ref state);
                return false; // Fire-and-forget

            case CalculatorActorHandlerIds.Factorial:
                Factorial_Execute(
                    *(FactorialRequest*)requestPtr,
                    out *(FactorialResponse*)responsePtr,
                    ref state);
                return true;

            case CalculatorActorHandlerIds.GetAccumulator:
                GetAccumulator_Execute(
                    *(GetAccumulatorRequest*)requestPtr,
                    out *(GetAccumulatorResponse*)responsePtr,
                    ref state);
                return true;

            case CalculatorActorHandlerIds.Reset:
                Reset_Execute(
                    *(ResetRequest*)requestPtr,
                    ref state);
                return false; // Fire-and-forget

            default:
                // Unknown handler - should never happen if generated correctly
                return false;
        }
    }

    #endregion
}
