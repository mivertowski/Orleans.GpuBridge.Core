// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans
// Copyright (c) 2025 Michael Ivertowski

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Orleans.GpuBridge.Generators.Models;

namespace Orleans.GpuBridge.Generators.CodeGeneration;

/// <summary>
/// Generates blittable message structs for GPU handler methods.
/// These structs are used for CPU-GPU data transfer in ring kernel messaging.
/// </summary>
public static class MessageStructBuilder
{
    /// <summary>
    /// Generates all message structs for a GPU actor.
    /// </summary>
    /// <param name="actor">The actor information.</param>
    /// <returns>Generated C# source code for message structs.</returns>
    public static string GenerateMessageStructs(GpuActorInfo actor)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans");
        sb.AppendLine("// Copyright (c) 2025 Michael Ivertowski");
        sb.AppendLine("//");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GpuNativeActorGenerator.");
        sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.AppendLine($"namespace {actor.Namespace}.Generated;");
        sb.AppendLine();

        // Generate state struct if actor has state
        sb.AppendLine("#region State");
        sb.AppendLine();

        if (actor.HasState)
        {
            GenerateStateStruct(sb, actor);
        }
        else
        {
            // Generate default state struct
            GenerateDefaultStateStruct(sb, actor);
        }

        sb.AppendLine();
        sb.AppendLine("#endregion");
        sb.AppendLine();

        // Generate handler ID constants class
        sb.AppendLine("#region Handler ID Constants");
        sb.AppendLine();
        GenerateHandlerIdConstants(sb, actor);
        sb.AppendLine();
        sb.AppendLine("#endregion");
        sb.AppendLine();

        // Generate request message structs
        sb.AppendLine("#region Request Messages");
        sb.AppendLine();

        foreach (var handler in actor.Handlers)
        {
            GenerateRequestStruct(sb, actor, handler);
            sb.AppendLine();
        }

        sb.AppendLine("#endregion");
        sb.AppendLine();

        // Generate response message structs
        sb.AppendLine("#region Response Messages");
        sb.AppendLine();

        foreach (var handler in actor.Handlers)
        {
            if (handler.HasReturnValue && handler.ReturnTypeName != "void")
            {
                GenerateResponseStruct(sb, actor, handler);
                sb.AppendLine();
            }
        }

        sb.AppendLine("#endregion");

        return sb.ToString();
    }

    /// <summary>
    /// Generates a default state struct when actor doesn't define explicit state.
    /// </summary>
    private static void GenerateDefaultStateStruct(StringBuilder sb, GpuActorInfo actor)
    {
        var stateName = GetStateStructName(actor);

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// GPU-resident state for {GetActorBaseName(actor)}.");
        sb.AppendLine("/// Stored in GPU memory for sub-microsecond access by ring kernel.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 8)]");
        sb.AppendLine($"public struct {stateName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Accumulated result from operations.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public long Accumulator;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Last computed factorial result.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public long LastFactorial;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Count of operations performed.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public long OperationCount;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Reserved for alignment.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    private readonly long _reserved;");
        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates the state struct for GPU-resident state.
    /// </summary>
    private static void GenerateStateStruct(StringBuilder sb, GpuActorInfo actor)
    {
        var stateName = GetStateStructName(actor);

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// GPU-resident state for {GetActorBaseName(actor)}.");
        sb.AppendLine("/// Stored in GPU memory for sub-microsecond access by ring kernel.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 8)]");
        sb.AppendLine($"public struct {stateName}");
        sb.AppendLine("{");

        foreach (var state in actor.StateProperties)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {state.Name}.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public {state.TypeName} {state.Name};");
            sb.AppendLine();
        }

        // Add operation count if not already present
        if (!actor.StateProperties.Any(s => s.Name == "OperationCount"))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Count of operations performed.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public long OperationCount;");
            sb.AppendLine();
        }

        // Add padding if needed for alignment
        var totalFields = actor.StateProperties.Length + 1; // +1 for OperationCount
        if (totalFields % 2 != 0)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Reserved for alignment.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    private readonly long _reserved;");
        }

        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates handler ID constants class.
    /// </summary>
    private static void GenerateHandlerIdConstants(StringBuilder sb, GpuActorInfo actor)
    {
        var className = GetHandlerIdClassName(actor);

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Handler ID constants for {GetActorBaseName(actor)}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {className}");
        sb.AppendLine("{");

        foreach (var handler in actor.Handlers)
        {
            var handlerName = GetHandlerIdConstantName(handler.MethodName);
            sb.AppendLine($"    /// <summary>Handler ID for {handler.MethodName}</summary>");
            sb.AppendLine($"    public const int {handlerName} = {handler.MessageTypeId};");
            sb.AppendLine();
        }

        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates the request message struct for a handler.
    /// </summary>
    private static void GenerateRequestStruct(StringBuilder sb, GpuActorInfo actor, GpuHandlerInfo handler)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Request message for {handler.MethodName} handler.");
        sb.AppendLine("/// </summary>");

        // Calculate pack size based on largest field
        var packSize = GetOptimalPackSize(handler.Parameters);
        sb.AppendLine($"[StructLayout(LayoutKind.Sequential, Pack = {packSize})]");
        sb.AppendLine($"public struct {handler.RequestStructName}");
        sb.AppendLine("{");

        if (handler.Parameters.Length == 0)
        {
            // Empty request needs placeholder for struct validity
            sb.AppendLine("    /// <summary>Placeholder for empty request (0 bytes not allowed)</summary>");
            sb.AppendLine("    private readonly int _placeholder;");
        }
        else
        {
            foreach (var param in handler.Parameters)
            {
                var fieldName = char.ToUpperInvariant(param.Name[0]) + param.Name.Substring(1);
                var description = GetParameterDescription(param);

                sb.AppendLine($"    /// <summary>{description}</summary>");
                sb.AppendLine($"    public {param.TypeName} {fieldName};");
                sb.AppendLine();
            }

            // Add padding if needed for alignment
            if (NeedsPadding(handler.Parameters, packSize))
            {
                sb.AppendLine("    /// <summary>Padding for alignment</summary>");
                sb.AppendLine($"    private readonly int _padding;");
            }
        }

        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates the response message struct for a handler.
    /// </summary>
    private static void GenerateResponseStruct(StringBuilder sb, GpuActorInfo actor, GpuHandlerInfo handler)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Response message for {handler.MethodName} handler.");
        sb.AppendLine("/// </summary>");

        // Pack size based on return type
        var packSize = GetPackSizeForType(handler.ReturnTypeName);
        sb.AppendLine($"[StructLayout(LayoutKind.Sequential, Pack = {packSize})]");
        sb.AppendLine($"public struct {handler.ResponseStructName}");
        sb.AppendLine("{");

        // Determine result field name based on handler type
        var resultFieldName = GetResponseFieldName(handler);
        var description = GetResultDescription(handler);

        sb.AppendLine($"    /// <summary>{description}</summary>");
        sb.AppendLine($"    public {handler.ReturnTypeName} {resultFieldName};");

        // Add padding for smaller types to maintain alignment
        if (NeedsResponsePadding(handler.ReturnTypeName, packSize))
        {
            sb.AppendLine();
            sb.AppendLine("    /// <summary>Padding for alignment</summary>");
            sb.AppendLine("    private readonly int _padding;");
        }

        sb.AppendLine("}");
    }

    /// <summary>
    /// Gets the actor base name (without I prefix if present).
    /// </summary>
    private static string GetActorBaseName(GpuActorInfo actor)
    {
        var name = actor.InterfaceName;
        if (name.StartsWith("I", StringComparison.Ordinal) && name.Length > 1 && char.IsUpper(name[1]))
        {
            return name.Substring(1);
        }
        return name;
    }

    /// <summary>
    /// Gets the state struct name for an actor.
    /// </summary>
    private static string GetStateStructName(GpuActorInfo actor)
    {
        return $"{GetActorBaseName(actor)}State";
    }

    /// <summary>
    /// Gets the handler ID class name for an actor.
    /// </summary>
    private static string GetHandlerIdClassName(GpuActorInfo actor)
    {
        return $"{GetActorBaseName(actor)}HandlerIds";
    }

    /// <summary>
    /// Gets the handler ID constant name from a method name.
    /// </summary>
    private static string GetHandlerIdConstantName(string methodName)
    {
        // Remove Async suffix if present
        return methodName.EndsWith("Async", StringComparison.Ordinal)
            ? methodName.Substring(0, methodName.Length - 5)
            : methodName;
    }

    /// <summary>
    /// Gets the optimal pack size based on parameter types.
    /// </summary>
    private static int GetOptimalPackSize(ImmutableArray<GpuParameterInfo> parameters)
    {
        if (parameters.Length == 0)
            return 4;

        var hasLong = parameters.Any(p => IsLongType(p.TypeName));
        return hasLong ? 8 : 4;
    }

    /// <summary>
    /// Gets pack size for a single type.
    /// </summary>
    private static int GetPackSizeForType(string typeName)
    {
        return IsLongType(typeName) ? 8 : 4;
    }

    /// <summary>
    /// Checks if type requires 8-byte alignment.
    /// </summary>
    private static bool IsLongType(string typeName)
    {
        return typeName is "long" or "ulong" or "double" or "Int64" or "UInt64" or "Double";
    }

    /// <summary>
    /// Checks if padding is needed for alignment.
    /// </summary>
    private static bool NeedsPadding(ImmutableArray<GpuParameterInfo> parameters, int packSize)
    {
        // Calculate current struct size
        var size = 0;
        foreach (var param in parameters)
        {
            size += GetTypeSize(param.TypeName);
        }

        // Need padding if size is not aligned to pack size
        return packSize == 8 && size % 8 != 0;
    }

    /// <summary>
    /// Checks if response needs padding.
    /// </summary>
    private static bool NeedsResponsePadding(string returnTypeName, int packSize)
    {
        var size = GetTypeSize(returnTypeName);
        return packSize == 4 && size == 4;
    }

    /// <summary>
    /// Gets size in bytes for a type.
    /// </summary>
    private static int GetTypeSize(string typeName)
    {
        return typeName switch
        {
            "byte" or "sbyte" or "Byte" or "SByte" => 1,
            "short" or "ushort" or "Int16" or "UInt16" => 2,
            "int" or "uint" or "float" or "Int32" or "UInt32" or "Single" => 4,
            "long" or "ulong" or "double" or "Int64" or "UInt64" or "Double" => 8,
            "decimal" or "Decimal" => 16,
            _ => 4 // Default to 4 for unknown types
        };
    }

    /// <summary>
    /// Gets description for a parameter.
    /// </summary>
    private static string GetParameterDescription(GpuParameterInfo param)
    {
        var name = param.Name;

        // Generate sensible descriptions based on common naming patterns
        if (name.Equals("a", StringComparison.OrdinalIgnoreCase))
            return "First operand";
        if (name.Equals("b", StringComparison.OrdinalIgnoreCase))
            return "Second operand";
        if (name.Equals("n", StringComparison.OrdinalIgnoreCase))
            return "Input value";
        if (name.Equals("x", StringComparison.OrdinalIgnoreCase))
            return "X value";
        if (name.Equals("y", StringComparison.OrdinalIgnoreCase))
            return "Y value";

        // Default: Use capitalized name
        return $"{char.ToUpperInvariant(name[0])}{name.Substring(1)} parameter";
    }

    /// <summary>
    /// Gets the response field name based on handler type.
    /// </summary>
    private static string GetResponseFieldName(GpuHandlerInfo handler)
    {
        var methodLower = handler.MethodName.ToLowerInvariant();

        // GetAccumulator should use Value
        if (methodLower.Contains("getaccumulator") || (methodLower.Contains("get") && methodLower.Contains("accumulator")))
        {
            return "Value";
        }

        // Most others use Result
        return "Result";
    }

    /// <summary>
    /// Gets description for result field.
    /// </summary>
    private static string GetResultDescription(GpuHandlerInfo handler)
    {
        var methodLower = handler.MethodName.ToLowerInvariant();

        if (methodLower.Contains("add"))
            return "Sum result";
        if (methodLower.Contains("subtract"))
            return "Difference result";
        if (methodLower.Contains("multiply"))
            return "Product result";
        if (methodLower.Contains("divide"))
            return "Division result";
        if (methodLower.Contains("factorial"))
            return "Factorial result";
        if (methodLower.Contains("getaccumulator") || (methodLower.Contains("get") && methodLower.Contains("accumulator")))
            return "Accumulator value";

        return "Operation result";
    }
}
