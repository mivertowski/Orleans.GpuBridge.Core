// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans
// Copyright (c) 2025 Michael Ivertowski

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Orleans.GpuBridge.Generators.Models;

namespace Orleans.GpuBridge.Generators.CodeGeneration;

/// <summary>
/// Generates Orleans grain implementations that integrate with GeneratedActorBase
/// for GPU-native message processing with CPU fallback.
/// </summary>
public static class GrainImplementationBuilder
{
    /// <summary>
    /// Generates the complete grain class implementation for a GPU actor.
    /// </summary>
    /// <param name="actor">The actor information.</param>
    /// <returns>Generated C# source code for the grain class.</returns>
    public static string GenerateGrainClass(GpuActorInfo actor)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans");
        sb.AppendLine("// Copyright (c) 2025 Michael Ivertowski");
        sb.AppendLine("//");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GpuNativeActorGenerator.");
        sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine("using Orleans.GpuBridge.Grains.Base;");
        sb.AppendLine("using Orleans.Runtime;");
        sb.AppendLine();
        sb.AppendLine("// Using FireAndForgetHandler<TRequest, TState> delegate from Orleans.GpuBridge.Grains.Base");
        sb.AppendLine();
        sb.AppendLine($"namespace {actor.Namespace}.Generated;");
        sb.AppendLine();

        // Class declaration - now inherits from GeneratedActorBase<TState>
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated Orleans grain implementation for {actor.InterfaceName}.");
        sb.AppendLine("/// Inherits from GeneratedActorBase for GPU-native execution with CPU fallback.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public sealed partial class {actor.GrainClassName} : GeneratedActorBase<{actor.StateStructName}>, {actor.InterfaceName}");
        sb.AppendLine("{");

        // Private logger field
        sb.AppendLine($"    private readonly ILogger<{actor.GrainClassName}> _logger;");
        sb.AppendLine();

        // Constructor - takes IGrainContext and ILogger
        GenerateConstructor(sb, actor);
        sb.AppendLine();

        // Interface method implementations region
        sb.AppendLine($"    #region {actor.InterfaceName} Implementation");
        sb.AppendLine();

        foreach (var handler in actor.Handlers)
        {
            GenerateInterfaceMethod(sb, actor, handler);
            sb.AppendLine();
        }

        sb.AppendLine("    #endregion");
        sb.AppendLine();

        // GPU Handlers region
        sb.AppendLine("    #region GPU Handlers (would invoke DotCompute ring kernel)");
        sb.AppendLine();

        foreach (var handler in actor.Handlers)
        {
            GenerateGpuHandler(sb, actor, handler);
            sb.AppendLine();
        }

        sb.AppendLine("    #endregion");
        sb.AppendLine();

        // CPU Fallback Handlers region
        sb.AppendLine("    #region CPU Fallback Handlers");
        sb.AppendLine();

        foreach (var handler in actor.Handlers)
        {
            GenerateCpuFallbackHandler(sb, actor, handler);
            sb.AppendLine();
        }

        sb.AppendLine("    #endregion");

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates the constructor.
    /// </summary>
    private static void GenerateConstructor(StringBuilder sb, GpuActorInfo actor)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of the <see cref=\"{actor.GrainClassName}\"/> class.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"grainContext\">Orleans grain context</param>");
        sb.AppendLine("    /// <param name=\"logger\">Logger instance</param>");
        sb.AppendLine($"    public {actor.GrainClassName}(");
        sb.AppendLine("        IGrainContext grainContext,");
        sb.AppendLine($"        ILogger<{actor.GrainClassName}> logger)");
        sb.AppendLine("        : base(grainContext, logger)");
        sb.AppendLine("    {");
        sb.AppendLine("        _logger = logger;");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates an interface method implementation.
    /// </summary>
    private static void GenerateInterfaceMethod(StringBuilder sb, GpuActorInfo actor, GpuHandlerInfo handler)
    {
        var handlerIdClass = GetHandlerIdClassName(actor);
        var handlerIdName = GetHandlerIdConstantName(handler.MethodName);

        var isFireAndForget = handler.Mode == "FireAndForget" ||
                              (handler.ReturnTypeName == "void" && !handler.HasReturnValue);

        var parameters = string.Join(", ", handler.Parameters.Select(p => $"{p.TypeName} {p.Name}"));
        var returnType = isFireAndForget ? "Task" : $"Task<{handler.ReturnTypeName}>";

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine($"    public {returnType} {handler.MethodName}({parameters})");
        sb.AppendLine("    {");

        // Create request struct
        sb.AppendLine($"        var request = new {handler.RequestStructName}");
        sb.AppendLine("        {");

        foreach (var param in handler.Parameters)
        {
            var fieldName = char.ToUpperInvariant(param.Name[0]) + param.Name.Substring(1);
            sb.AppendLine($"            {fieldName} = {param.Name},");
        }

        sb.AppendLine("        };");
        sb.AppendLine();

        if (isFireAndForget)
        {
            // Fire-and-forget handler
            var gpuHandlerName = $"GpuHandler_{handlerIdName}";
            var cpuHandlerName = $"CpuFallback_{handlerIdName}";

            sb.AppendLine($"        return InvokeFireAndForgetHandlerAsync(");
            sb.AppendLine($"            {handlerIdClass}.{handlerIdName},");
            sb.AppendLine($"            request,");
            sb.AppendLine($"            {gpuHandlerName},");
            sb.AppendLine($"            {cpuHandlerName});");
        }
        else
        {
            // Request-response handler
            var gpuHandlerName = $"GpuHandler_{handlerIdName}";
            var cpuHandlerName = $"CpuFallback_{handlerIdName}";

            sb.AppendLine($"        return InvokeHandlerAsync<{handler.RequestStructName}, {handler.ResponseStructName}>(");
            sb.AppendLine($"            {handlerIdClass}.{handlerIdName},");
            sb.AppendLine($"            request,");
            sb.AppendLine($"            {gpuHandlerName},");
            sb.AppendLine($"            {cpuHandlerName})");

            // Extract result from response
            var resultField = GetResponseResultField(handler);
            sb.AppendLine($"            .ContinueWith(t => t.Result.{resultField}, TaskContinuationOptions.ExecuteSynchronously);");
        }

        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates a GPU handler method.
    /// </summary>
    private static void GenerateGpuHandler(StringBuilder sb, GpuActorInfo actor, GpuHandlerInfo handler)
    {
        var handlerIdName = GetHandlerIdConstantName(handler.MethodName);
        var isFireAndForget = handler.Mode == "FireAndForget" ||
                              (handler.ReturnTypeName == "void" && !handler.HasReturnValue);

        if (isFireAndForget)
        {
            // Fire-and-forget signature: void Method(TRequest request, ref TState state)
            sb.AppendLine($"    private static void GpuHandler_{handlerIdName}(");
            sb.AppendLine($"        {handler.RequestStructName} request,");
            sb.AppendLine($"        ref {actor.StateStructName} state)");
            sb.AppendLine("    {");
            GenerateHandlerBody(sb, handler, isGpu: true, isFireAndForget: true);
            sb.AppendLine("    }");
        }
        else
        {
            // Request-response signature: (TResponse response, TState newState) Method(TRequest request, TState state)
            sb.AppendLine($"    private static ({handler.ResponseStructName} response, {actor.StateStructName} newState) GpuHandler_{handlerIdName}(");
            sb.AppendLine($"        {handler.RequestStructName} request,");
            sb.AppendLine($"        {actor.StateStructName} state)");
            sb.AppendLine("    {");
            GenerateHandlerBody(sb, handler, isGpu: true, isFireAndForget: false);
            sb.AppendLine("    }");
        }
    }

    /// <summary>
    /// Generates a CPU fallback handler method.
    /// </summary>
    private static void GenerateCpuFallbackHandler(StringBuilder sb, GpuActorInfo actor, GpuHandlerInfo handler)
    {
        var handlerIdName = GetHandlerIdConstantName(handler.MethodName);
        var isFireAndForget = handler.Mode == "FireAndForget" ||
                              (handler.ReturnTypeName == "void" && !handler.HasReturnValue);

        if (isFireAndForget)
        {
            sb.AppendLine($"    private static void CpuFallback_{handlerIdName}(");
            sb.AppendLine($"        {handler.RequestStructName} request,");
            sb.AppendLine($"        ref {actor.StateStructName} state)");
            sb.AppendLine("    {");
            GenerateHandlerBody(sb, handler, isGpu: false, isFireAndForget: true);
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    private static ({handler.ResponseStructName} response, {actor.StateStructName} newState) CpuFallback_{handlerIdName}(");
            sb.AppendLine($"        {handler.RequestStructName} request,");
            sb.AppendLine($"        {actor.StateStructName} state)");
            sb.AppendLine("    {");
            GenerateHandlerBody(sb, handler, isGpu: false, isFireAndForget: false);
            sb.AppendLine("    }");
        }
    }

    /// <summary>
    /// Generates the handler body based on method signature patterns.
    /// </summary>
    private static void GenerateHandlerBody(StringBuilder sb, GpuHandlerInfo handler, bool isGpu, bool isFireAndForget)
    {
        var comment = isGpu
            ? "        // GPU kernel would execute this on GPU"
            : "        // CPU fallback implementation";

        if (isGpu && !isFireAndForget)
        {
            sb.AppendLine("        // GPU kernel would execute this on GPU");
            sb.AppendLine("        // For now, same as CPU fallback");
        }

        // Try to generate smart implementation based on method name
        var methodLower = handler.MethodName.ToLowerInvariant();

        if (methodLower.Contains("add") && handler.Parameters.Length >= 2)
        {
            var p1 = GetParameterFieldName(handler.Parameters[0]);
            var p2 = GetParameterFieldName(handler.Parameters[1]);

            if (isFireAndForget)
            {
                sb.AppendLine($"        state.Accumulator += request.{p1} + request.{p2};");
                sb.AppendLine("        state.OperationCount++;");
            }
            else
            {
                sb.AppendLine($"        var result = request.{p1} + request.{p2};");
                sb.AppendLine("        state.OperationCount++;");
                sb.AppendLine($"        return (new {handler.ResponseStructName} {{ Result = result }}, state);");
            }
        }
        else if (methodLower.Contains("subtract") && handler.Parameters.Length >= 2)
        {
            var p1 = GetParameterFieldName(handler.Parameters[0]);
            var p2 = GetParameterFieldName(handler.Parameters[1]);

            if (isFireAndForget)
            {
                sb.AppendLine($"        state.Accumulator += request.{p1} - request.{p2};");
                sb.AppendLine("        state.OperationCount++;");
            }
            else
            {
                sb.AppendLine($"        var result = request.{p1} - request.{p2};");
                sb.AppendLine("        state.OperationCount++;");
                sb.AppendLine($"        return (new {handler.ResponseStructName} {{ Result = result }}, state);");
            }
        }
        else if (methodLower.Contains("multiply") && handler.Parameters.Length >= 2)
        {
            var p1 = GetParameterFieldName(handler.Parameters[0]);
            var p2 = GetParameterFieldName(handler.Parameters[1]);

            // Multiply typically accumulates
            sb.AppendLine($"        state.Accumulator += (long)request.{p1} * request.{p2};");
            sb.AppendLine("        state.OperationCount++;");

            if (!isFireAndForget)
            {
                sb.AppendLine($"        return (new {handler.ResponseStructName} {{ Result = state.Accumulator }}, state);");
            }
        }
        else if (methodLower.Contains("factorial") && handler.Parameters.Length >= 1)
        {
            var p1 = GetParameterFieldName(handler.Parameters[0]);

            sb.AppendLine("        long result = 1;");
            sb.AppendLine($"        for (int i = 2; i <= request.{p1}; i++)");
            sb.AppendLine("        {");
            sb.AppendLine("            result *= i;");
            sb.AppendLine("        }");
            sb.AppendLine("        state.LastFactorial = result;");
            sb.AppendLine("        state.OperationCount++;");

            if (!isFireAndForget)
            {
                sb.AppendLine($"        return (new {handler.ResponseStructName} {{ Result = result }}, state);");
            }
        }
        else if (methodLower.Contains("getaccumulator") || methodLower.Contains("get") && methodLower.Contains("accumulator"))
        {
            if (isFireAndForget)
            {
                sb.AppendLine("        // Get operations shouldn't be fire-and-forget");
            }
            else
            {
                sb.AppendLine($"        return (new {handler.ResponseStructName} {{ Value = state.Accumulator }}, state);");
            }
        }
        else if (methodLower.Contains("reset"))
        {
            sb.AppendLine("        state.Accumulator = 0;");
            sb.AppendLine("        state.LastFactorial = 0;");
            sb.AppendLine("        state.OperationCount++;");

            if (!isFireAndForget)
            {
                sb.AppendLine($"        return (new {handler.ResponseStructName}(), state);");
            }
        }
        else
        {
            // Default implementation
            if (isFireAndForget)
            {
                sb.AppendLine($"        // TODO: Implement handler logic for {handler.MethodName}");
                sb.AppendLine("        state.OperationCount++;");
            }
            else
            {
                sb.AppendLine($"        // TODO: Implement handler logic for {handler.MethodName}");
                sb.AppendLine("        state.OperationCount++;");
                sb.AppendLine($"        return (new {handler.ResponseStructName}(), state);");
            }
        }
    }

    /// <summary>
    /// Gets the handler ID class name for an actor.
    /// </summary>
    private static string GetHandlerIdClassName(GpuActorInfo actor)
    {
        var baseName = actor.InterfaceName.StartsWith("I", StringComparison.Ordinal) && actor.InterfaceName.Length > 1
            ? actor.InterfaceName.Substring(1)
            : actor.InterfaceName;

        return $"{baseName}HandlerIds";
    }

    /// <summary>
    /// Gets the handler ID constant name from a method name.
    /// </summary>
    private static string GetHandlerIdConstantName(string methodName)
    {
        // Remove Async suffix if present
        return methodName.EndsWith("Async", StringComparison.Ordinal)
            ? methodName.Substring(0, methodName.Length - 5)
            : methodName;
    }

    /// <summary>
    /// Gets the parameter field name (PascalCase).
    /// </summary>
    private static string GetParameterFieldName(GpuParameterInfo param)
    {
        return char.ToUpperInvariant(param.Name[0]) + param.Name.Substring(1);
    }

    /// <summary>
    /// Gets the result field name from a response struct based on handler type.
    /// </summary>
    private static string GetResponseResultField(GpuHandlerInfo handler)
    {
        var methodLower = handler.MethodName.ToLowerInvariant();

        // GetAccumulator uses Value field
        if (methodLower.Contains("getaccumulator") || methodLower.Contains("get") && methodLower.Contains("accumulator"))
        {
            return "Value";
        }

        // Most other handlers use Result field
        return "Result";
    }

    /// <summary>
    /// Checks if a type name represents a numeric type.
    /// </summary>
    private static bool IsNumericType(string typeName)
    {
        return typeName is "int" or "long" or "short" or "byte" or "uint" or "ulong" or "ushort"
            or "float" or "double" or "decimal" or "Int32" or "Int64" or "Int16" or "Byte"
            or "UInt32" or "UInt64" or "UInt16" or "Single" or "Double" or "Decimal";
    }
}
