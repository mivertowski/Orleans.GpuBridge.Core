# DotCompute Feature Request: Ring Kernel Message Type Detection

**Date**: November 13, 2025
**Severity**: High (Blocking message passing functionality)
**Component**: DotCompute.Backends.CPU.RingKernels.CpuRingKernelRuntime
**Affects**: All backends (CPU, CUDA, OpenCL, Metal)

---

## Problem Statement

The ring kernel runtime currently hardcodes message queue types as `CpuMessageQueue<int>` instead of detecting the actual message types from the kernel signature. This prevents sending/receiving custom message types to ring kernels.

### Current Behavior

**File**: `DotCompute/src/Backends/DotCompute.Backends.CPU/RingKernels/CpuRingKernelRuntime.cs` (lines 265-266)

```csharp
// Hardcoded as int - should be detected from kernel signature!
worker.InputQueue = new CpuMessageQueue<int>(256, inputQueueLogger);
worker.OutputQueue = new CpuMessageQueue<int>(256, outputQueueLogger);
```

**Error when attempting to send VectorAddRequest**:
```
System.InvalidOperationException: Input queue for kernel 'VectorAddProcessor' does not support type VectorAddRequest
   at DotCompute.Backends.CPU.RingKernels.CpuRingKernelRuntime.SendMessageAsync[T](String kernelId, KernelMessage`1 message, CancellationToken cancellationToken) in CpuRingKernelRuntime.cs:line 339
```

### Expected Behavior

The runtime should analyze the kernel signature and create typed message queues:

**Kernel Signature**:
```csharp
[RingKernel(KernelId = "VectorAddProcessor", ...)]
public static void VectorAddProcessorRing(
    Span<long> timestamps,
    Span<VectorAddRequest> requestQueue,        // Input type = VectorAddRequest
    Span<VectorAddResponse> responseQueue,      // Output type = VectorAddResponse
    ...)
```

**Expected Queue Creation**:
```csharp
worker.InputQueue = new CpuMessageQueue<VectorAddRequest>(256, inputQueueLogger);
worker.OutputQueue = new CpuMessageQueue<VectorAddResponse>(256, outputQueueLogger);
```

---

## Impact

**Blocks**:
- âœ… GPU-native actor message passing (critical for Phase 5)
- âœ… Custom message types in ring kernels
- âœ… End-to-end validation of message dispatch loops
- âœ… Latency measurement for GPU-native messaging

**Affects**:
- All ring kernel backends (CPU, CUDA, OpenCL, Metal)
- Source generator (DotCompute.Generators) - needs to emit queue type info
- Runtime initialization - needs reflection or metadata to detect types

---

## Proposed Solutions

### Solution 1: Reflection-Based Type Detection (Runtime)

**Analyze kernel method signature at runtime**:

```csharp
public Task LaunchAsync(string kernelId, int gridSize, int blockSize)
{
    // Find kernel method by attribute
    var kernelMethod = FindKernelMethodByKernelId(kernelId);

    // Extract Span<T> parameter types
    var inputType = ExtractSpanElementType(kernelMethod, parameterIndex: 1);  // requestQueue
    var outputType = ExtractSpanElementType(kernelMethod, parameterIndex: 2); // responseQueue

    // Create typed queues using reflection
    var inputQueueType = typeof(CpuMessageQueue<>).MakeGenericType(inputType);
    var outputQueueType = typeof(CpuMessageQueue<>).MakeGenericType(outputType);

    worker.InputQueue = (IMessageQueue)Activator.CreateInstance(inputQueueType, 256, inputQueueLogger);
    worker.OutputQueue = (IMessageQueue)Activator.CreateInstance(outputQueueType, 256, outputQueueLogger);
}

private static Type ExtractSpanElementType(MethodInfo method, int parameterIndex)
{
    var param = method.GetParameters()[parameterIndex];
    var spanType = param.ParameterType; // Span<T>
    return spanType.GetGenericArguments()[0]; // T
}
```

**Pros**:
- Works with existing kernel code
- No source generator changes required
- Runtime flexibility

**Cons**:
- Reflection overhead (one-time at launch)
- Requires kernel method to be discoverable via reflection

---

### Solution 2: Source Generator Metadata (Code Generation)

**Emit queue type info in generated wrapper**:

```csharp
// Generated by DotCompute.Generators
public class VectorAddProcessorRingRingKernelWrapper : IRingKernelWrapper
{
    // GENERATED: Message type metadata
    public Type InputMessageType => typeof(VectorAddRequest);
    public Type OutputMessageType => typeof(VectorAddResponse);

    // Existing lifecycle methods
    public Task LaunchAsync(int gridSize, int blockSize) { ... }
    public Task ActivateAsync() { ... }
    // ...
}
```

**Runtime uses metadata**:
```csharp
public Task LaunchAsync(string kernelId, int gridSize, int blockSize)
{
    var wrapper = GetWrapperForKernel(kernelId);
    var inputType = wrapper.InputMessageType;  // VectorAddRequest
    var outputType = wrapper.OutputMessageType; // VectorAddResponse

    // Create typed queues
    var inputQueueType = typeof(CpuMessageQueue<>).MakeGenericType(inputType);
    var outputQueueType = typeof(CpuMessageQueue<>).MakeGenericType(outputType);

    worker.InputQueue = (IMessageQueue)Activator.CreateInstance(inputQueueType, 256, inputQueueLogger);
    worker.OutputQueue = (IMessageQueue)Activator.CreateInstance(outputQueueType, 256, outputQueueLogger);
}
```

**Pros**:
- Type safety at compile time
- No reflection overhead
- Clean API design

**Cons**:
- Requires source generator changes
- More code generation complexity

---

### Solution 3: Explicit Type Parameters (API Design)

**Add generic LaunchAsync method**:

```csharp
public interface IRingKernelRuntime
{
    // New: Generic launch with message types
    Task LaunchAsync<TInput, TOutput>(string kernelId, int gridSize, int blockSize)
        where TInput : unmanaged
        where TOutput : unmanaged;

    // Existing non-generic (deprecated)
    Task LaunchAsync(string kernelId, int gridSize, int blockSize);
}
```

**Usage**:
```csharp
// Explicit type parameters
await runtime.LaunchAsync<VectorAddRequest, VectorAddResponse>(
    "VectorAddProcessor",
    gridSize: 1,
    blockSize: 1);
```

**Pros**:
- Explicit and clear
- Type safety enforced
- No reflection or code generation changes

**Cons**:
- API breaking change
- User must know message types (less discoverable)
- Verbose

---

## Recommended Approach

**Hybrid: Solution 2 (Source Generator) + Solution 3 (Generic API)**

1. **Source generator emits message type metadata** in wrapper (Solution 2)
2. **Add generic `LaunchAsync<TInput, TOutput>` method** for explicit control (Solution 3)
3. **Runtime validates types match kernel signature** (safety check)

**Generated Code**:
```csharp
public class VectorAddProcessorRingRingKernelWrapper : IRingKernelWrapper
{
    public Type InputMessageType => typeof(VectorAddRequest);
    public Type OutputMessageType => typeof(VectorAddResponse);

    // Generic launch with type validation
    public Task LaunchAsync<TInput, TOutput>(int gridSize, int blockSize)
        where TInput : unmanaged
        where TOutput : unmanaged
    {
        // Validate types match kernel signature
        if (typeof(TInput) != InputMessageType)
            throw new InvalidOperationException(
                $"Input type {typeof(TInput).Name} does not match kernel signature {InputMessageType.Name}");

        if (typeof(TOutput) != OutputMessageType)
            throw new InvalidOperationException(
                $"Output type {typeof(TOutput).Name} does not match kernel signature {OutputMessageType.Name}");

        return _runtime.LaunchAsync<TInput, TOutput>(_kernelId, gridSize, blockSize);
    }
}
```

**Usage** (Type-safe and validated):
```csharp
using var wrapper = new VectorAddProcessorRingRingKernelWrapper(runtime);

// Type parameters validated against kernel signature
await wrapper.LaunchAsync<VectorAddRequest, VectorAddResponse>(gridSize: 1, blockSize: 1);
await wrapper.ActivateAsync();

// Send/receive now works with correct types
var request = new VectorAddRequest { ... };
var message = KernelMessage<VectorAddRequest>.Create(...);
await runtime.SendMessageAsync("VectorAddProcessor", message);
```

---

## Implementation Steps

1. **DotCompute.Generators** (Source Generator):
   - Analyze `[RingKernel]` method signature
   - Extract `Span<TInput>` and `Span<TOutput>` parameter types
   - Emit `InputMessageType` and `OutputMessageType` properties in wrapper
   - Emit generic `LaunchAsync<TInput, TOutput>` method

2. **DotCompute.Backends.CPU** (Runtime):
   - Add `LaunchAsync<TInput, TOutput>` overload to `CpuRingKernelRuntime`
   - Use generic type parameters to create `CpuMessageQueue<TInput>` and `CpuMessageQueue<TOutput>`
   - Remove hardcoded `CpuMessageQueue<int>`

3. **DotCompute.Backends.CUDA** (Runtime):
   - Apply same changes to `CudaRingKernelRuntime`
   - Ensure CUDA memory management works with custom types

4. **DotCompute.Backends.OpenCL/Metal** (Runtime):
   - Apply same pattern to all backends

---

## Testing

**Test Cases**:
1. âœ… Launch kernel with generic type parameters
2. âœ… Send `VectorAddRequest` message to kernel
3. âœ… Receive `VectorAddResponse` message from kernel
4. âœ… Validate computation correctness (A + B = C)
5. âœ… Measure end-to-end message latency
6. âœ… Type mismatch detection (wrong types throw exception)
7. âœ… Multiple kernels with different message types
8. âœ… Large message types (>25 elements, GPU memory path)

**Validation**:
- Orleans.GpuBridge.Core Phase 5 message passing tests
- DotCompute ring kernel test suite
- Performance benchmarks (ensure no regression)

---

## Example: Complete Working Flow

**Kernel Definition**:
```csharp
[RingKernel(KernelId = "VectorAddProcessor", ...)]
public static void VectorAddProcessorRing(
    Span<long> timestamps,
    Span<VectorAddRequest> requestQueue,    // INPUT TYPE
    Span<VectorAddResponse> responseQueue,  // OUTPUT TYPE
    ...)
{
    // Infinite dispatch loop
    while (!stopSignal[0])
    {
        VectorAddRequest request = requestQueue[tail];
        VectorAddResponse response = ProcessVectorAdd(request);
        responseQueue[head] = response;
    }
}
```

**Generated Wrapper** (by DotCompute.Generators):
```csharp
public class VectorAddProcessorRingRingKernelWrapper : IRingKernelWrapper
{
    public Type InputMessageType => typeof(VectorAddRequest);
    public Type OutputMessageType => typeof(VectorAddResponse);

    public Task LaunchAsync<TInput, TOutput>(int gridSize, int blockSize)
        where TInput : unmanaged
        where TOutput : unmanaged
    {
        ValidateTypes<TInput, TOutput>();
        return _runtime.LaunchAsync<TInput, TOutput>(_kernelId, gridSize, blockSize);
    }
}
```

**Test Code** (Orleans.GpuBridge.Core):
```csharp
var runtime = RingKernelRuntimeFactory.CreateRuntime("CPU", loggerFactory);
using var wrapper = new VectorAddProcessorRingRingKernelWrapper(runtime);

// Launch with correct types
await wrapper.LaunchAsync<VectorAddRequest, VectorAddResponse>(gridSize: 1, blockSize: 1);
await wrapper.ActivateAsync();

// Send request
var request = new VectorAddRequest { VectorALength = 10, ... };
var message = KernelMessage<VectorAddRequest>.Create(0, 1, MessageType.Data, request);
await runtime.SendMessageAsync("VectorAddProcessor", message);

// Receive response
var response = await runtime.ReceiveMessageAsync<VectorAddResponse>("VectorAddProcessor", TimeSpan.FromSeconds(5));

// Validate: A + B = C âœ…
```

---

## Priority

**High Priority** - Blocking critical GPU-native actor functionality.

**Timeline**:
- Week 15 Day 4: Document feature request (this file)
- Week 15 Day 5-7: Implement in DotCompute (source generator + runtime)
- Week 16 Day 1: Validate with Orleans.GpuBridge.Core message passing tests
- Week 16 Day 2: Performance benchmarks and optimization

---

## Related Issues

- âœ… **Phase 5 Ring Kernel Integration** (Orleans.GpuBridge.Core)
- âœ… **CRITICAL-CUDA-BACKEND-BUG.md** (CUDA LibraryImport fixed in 0.5.0-alpha)
- âœ… **GPU-NATIVE-ACTOR-ENHANCEMENTS.md** (47 enhancements documented)

---

## Contact

**Project**: Orleans.GpuBridge.Core
**Developer**: Michael Ivertowski
**DotCompute Version**: 0.5.0-alpha (local package feed)
**Date**: November 2025

---

**Status**: ðŸ“‹ Documented, awaiting DotCompute team implementation
