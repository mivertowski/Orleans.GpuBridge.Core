// Orleans.GpuBridge - GPU-native distributed computing for Microsoft Orleans
// Copyright (c) 2025 Michael Ivertowski
//
// <auto-generated>
// This code was generated by GpuNativeActorGenerator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Orleans.GpuBridge.Grains.Base;
using Orleans.Runtime;

// Using FireAndForgetHandler<TRequest, TState> delegate from Orleans.GpuBridge.Grains.Base

namespace Orleans.GpuBridge.Grains.Generated;

/// <summary>
/// Generated Orleans grain implementation for ICalculatorActor.
/// Inherits from GeneratedActorBase for GPU-native execution with CPU fallback.
/// </summary>
public sealed partial class CalculatorActorGrain : GeneratedActorBase<CalculatorActorState>, ICalculatorActor
{
    private readonly ILogger<CalculatorActorGrain> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="CalculatorActorGrain"/> class.
    /// </summary>
    /// <param name="grainContext">Orleans grain context</param>
    /// <param name="logger">Logger instance</param>
    public CalculatorActorGrain(
        IGrainContext grainContext,
        ILogger<CalculatorActorGrain> logger)
        : base(grainContext, logger)
    {
        _logger = logger;
    }

    #region ICalculatorActor Implementation

    /// <inheritdoc/>
    public Task<int> AddAsync(int a, int b)
    {
        var request = new AddRequest { A = a, B = b };

        return InvokeHandlerAsync<AddRequest, AddResponse>(
            CalculatorActorHandlerIds.Add,
            request,
            GpuHandler_Add,
            CpuFallback_Add)
            .ContinueWith(t => t.Result.Result, TaskContinuationOptions.ExecuteSynchronously);
    }

    /// <inheritdoc/>
    public Task<int> SubtractAsync(int a, int b)
    {
        var request = new SubtractRequest { A = a, B = b };

        return InvokeHandlerAsync<SubtractRequest, SubtractResponse>(
            CalculatorActorHandlerIds.Subtract,
            request,
            GpuHandler_Subtract,
            CpuFallback_Subtract)
            .ContinueWith(t => t.Result.Result, TaskContinuationOptions.ExecuteSynchronously);
    }

    /// <inheritdoc/>
    public Task MultiplyAsync(int a, int b)
    {
        var request = new MultiplyRequest { A = a, B = b };

        return InvokeFireAndForgetHandlerAsync(
            CalculatorActorHandlerIds.Multiply,
            request,
            GpuHandler_Multiply,
            CpuFallback_Multiply);
    }

    /// <inheritdoc/>
    public Task<long> FactorialAsync(int n)
    {
        var request = new FactorialRequest { N = n };

        return InvokeHandlerAsync<FactorialRequest, FactorialResponse>(
            CalculatorActorHandlerIds.Factorial,
            request,
            GpuHandler_Factorial,
            CpuFallback_Factorial)
            .ContinueWith(t => t.Result.Result, TaskContinuationOptions.ExecuteSynchronously);
    }

    /// <inheritdoc/>
    public Task<long> GetAccumulatorAsync()
    {
        var request = new GetAccumulatorRequest();

        return InvokeHandlerAsync<GetAccumulatorRequest, GetAccumulatorResponse>(
            CalculatorActorHandlerIds.GetAccumulator,
            request,
            GpuHandler_GetAccumulator,
            CpuFallback_GetAccumulator)
            .ContinueWith(t => t.Result.Value, TaskContinuationOptions.ExecuteSynchronously);
    }

    /// <inheritdoc/>
    public Task ResetAsync()
    {
        var request = new ResetRequest();

        return InvokeFireAndForgetHandlerAsync(
            CalculatorActorHandlerIds.Reset,
            request,
            GpuHandler_Reset,
            CpuFallback_Reset);
    }

    #endregion

    #region GPU Handlers (would invoke DotCompute ring kernel)

    private static (AddResponse response, CalculatorActorState newState) GpuHandler_Add(
        AddRequest request,
        CalculatorActorState state)
    {
        // GPU kernel would execute this on GPU
        // For now, same as CPU fallback
        var result = request.A + request.B;
        state.OperationCount++;
        return (new AddResponse { Result = result }, state);
    }

    private static (SubtractResponse response, CalculatorActorState newState) GpuHandler_Subtract(
        SubtractRequest request,
        CalculatorActorState state)
    {
        var result = request.A - request.B;
        state.OperationCount++;
        return (new SubtractResponse { Result = result }, state);
    }

    private static void GpuHandler_Multiply(
        MultiplyRequest request,
        ref CalculatorActorState state)
    {
        state.Accumulator += (long)request.A * request.B;
        state.OperationCount++;
    }

    private static (FactorialResponse response, CalculatorActorState newState) GpuHandler_Factorial(
        FactorialRequest request,
        CalculatorActorState state)
    {
        long result = 1;
        for (int i = 2; i <= request.N; i++)
        {
            result *= i;
        }
        state.LastFactorial = result;
        state.OperationCount++;
        return (new FactorialResponse { Result = result }, state);
    }

    private static (GetAccumulatorResponse response, CalculatorActorState newState) GpuHandler_GetAccumulator(
        GetAccumulatorRequest request,
        CalculatorActorState state)
    {
        return (new GetAccumulatorResponse { Value = state.Accumulator }, state);
    }

    private static void GpuHandler_Reset(
        ResetRequest request,
        ref CalculatorActorState state)
    {
        state.Accumulator = 0;
        state.LastFactorial = 0;
        state.OperationCount++;
    }

    #endregion

    #region CPU Fallback Handlers

    private static (AddResponse response, CalculatorActorState newState) CpuFallback_Add(
        AddRequest request,
        CalculatorActorState state)
    {
        var result = request.A + request.B;
        state.OperationCount++;
        return (new AddResponse { Result = result }, state);
    }

    private static (SubtractResponse response, CalculatorActorState newState) CpuFallback_Subtract(
        SubtractRequest request,
        CalculatorActorState state)
    {
        var result = request.A - request.B;
        state.OperationCount++;
        return (new SubtractResponse { Result = result }, state);
    }

    private static void CpuFallback_Multiply(
        MultiplyRequest request,
        ref CalculatorActorState state)
    {
        state.Accumulator += (long)request.A * request.B;
        state.OperationCount++;
    }

    private static (FactorialResponse response, CalculatorActorState newState) CpuFallback_Factorial(
        FactorialRequest request,
        CalculatorActorState state)
    {
        long result = 1;
        for (int i = 2; i <= request.N; i++)
        {
            result *= i;
        }
        state.LastFactorial = result;
        state.OperationCount++;
        return (new FactorialResponse { Result = result }, state);
    }

    private static (GetAccumulatorResponse response, CalculatorActorState newState) CpuFallback_GetAccumulator(
        GetAccumulatorRequest request,
        CalculatorActorState state)
    {
        return (new GetAccumulatorResponse { Value = state.Accumulator }, state);
    }

    private static void CpuFallback_Reset(
        ResetRequest request,
        ref CalculatorActorState state)
    {
        state.Accumulator = 0;
        state.LastFactorial = 0;
        state.OperationCount++;
    }

    #endregion
}
